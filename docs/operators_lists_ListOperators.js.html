<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Moebio Framework: Source: operators/lists/ListOperators.js</title>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:700italic,400,700' rel='stylesheet' type='text/css'>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/style.css">
</head>

<body onload="prettyPrint()">

<div class='hide-mobile pin-left pint-top pin-bottom col2 quiet-scroll scroll-styled fixed'>

  <div class='clearfix fill-background dark center'>
    <div class='inline pad2y'>
      <a href="../">Moebio Framework</a> / <a href="index.html">Docs</a>
    </div>
  </div>
  <div class='pad1 small'>
    <div class="filter-block clearfix">
      <input type="text" id="filter-input" placeholder="Type to filter">
      <a href="#" id="clear-filter-button">x</a>
    </div>
    <div class='side'>
      <h3>Numbers</h3>
<div class="space-bottom1"><div class="pad0y"><strong class="capitalize" keyline-all>Classes</strong></div><ul>
<li class="code"><a href="Axis2D.html">Axis2D</a></li><li class="code"><a href="Interval.html">Interval</a></li><li class="code"><a href="Matrix.html">Matrix</a></li><li class="code"><a href="NumberList.html">NumberList</a></li><li class="code"><a href="NumberTable.html">NumberTable</a></li></ul></div><div class="space-bottom1"><div class="pad0y"><strong class="capitalize" keyline-all>Namespaces</strong></div><ul>
<li class="code"><a href="IntervalListOperators.html">IntervalListOperators</a></li><li class="code"><a href="IntervalTableOperators.html">IntervalTableOperators</a></li><li class="code"><a href="MatrixGenerators.html">MatrixGenerators</a></li><li class="code"><a href="NumberListConversions.html">NumberListConversions</a></li><li class="code"><a href="NumberListGenerators.html">NumberListGenerators</a></li><li class="code"><a href="NumberListOperators.html">NumberListOperators</a></li><li class="code"><a href="NumberOperators.html">NumberOperators</a></li><li class="code"><a href="NumberTableConversions.html">NumberTableConversions</a></li><li class="code"><a href="NumberTableFlowOperators.html">NumberTableFlowOperators</a></li><li class="code"><a href="NumberTableOperators.html">NumberTableOperators</a></li></ul></div><h3>Colors</h3>
<div class="space-bottom1"><div class="pad0y"><strong class="capitalize" keyline-all>Classes</strong></div><ul>
<li class="code"><a href="ColorList.html">ColorList</a></li><li class="code"><a href="ColorScale.html">ColorScale</a></li></ul></div><div class="space-bottom1"><div class="pad0y"><strong class="capitalize" keyline-all>Namespaces</strong></div><ul>
<li class="code"><a href="ColorGenerators.html">ColorGenerators</a></li><li class="code"><a href="ColorListGenerators.html">ColorListGenerators</a></li><li class="code"><a href="ColorListOperators.html">ColorListOperators</a></li><li class="code"><a href="ColorOperators.html">ColorOperators</a></li><li class="code"><a href="ColorScaleGenerators.html">ColorScaleGenerators</a></li><li class="code"><a href="ColorScales.html">ColorScales</a></li></ul></div><h3>Geo</h3>
<div class="space-bottom1"><div class="pad0y"><strong class="capitalize" keyline-all>Classes</strong></div><ul>
<li class="code"><a href="Country.html">Country</a></li><li class="code"><a href="CountryList.html">CountryList</a></li></ul></div><div class="space-bottom1"><div class="pad0y"><strong class="capitalize" keyline-all>Namespaces</strong></div><ul>
<li class="code"><a href="CountryListOperators.html">CountryListOperators</a></li><li class="code"><a href="CountryOperators.html">CountryOperators</a></li><li class="code"><a href="GeoOperators.html">GeoOperators</a></li></ul></div><h3>Basics</h3>
<div class="space-bottom1"><div class="pad0y"><strong class="capitalize" keyline-all>Classes</strong></div><ul>
<li class="code"><a href="DataModel.html">DataModel</a></li><li class="code"><a href="List.html">List</a></li><li class="code"><a href="Table.html">Table</a></li></ul></div><div class="space-bottom1"><div class="pad0y"><strong class="capitalize" keyline-all>Namespaces</strong></div><ul>
<li class="code"><a href="ListConversions.html">ListConversions</a></li><li class="code"><a href="ListGenerators.html">ListGenerators</a></li><li class="code"><a href="ListOperators.html">ListOperators</a></li><li class="code"><a href="ObjectConversions.html">ObjectConversions</a></li><li class="code"><a href="ObjectOperators.html">ObjectOperators</a></li><li class="code"><a href="TableConversions.html">TableConversions</a></li><li class="code"><a href="TableEncodings.html">TableEncodings</a></li><li class="code"><a href="TableGenerators.html">TableGenerators</a></li><li class="code"><a href="TableOperators.html">TableOperators</a></li></ul></div><h3>Dates</h3>
<div class="space-bottom1"><div class="pad0y"><strong class="capitalize" keyline-all>Classes</strong></div><ul>
<li class="code"><a href="DateAxis.html">DateAxis</a></li><li class="code"><a href="DateInterval.html">DateInterval</a></li><li class="code"><a href="DateList.html">DateList</a></li></ul></div><div class="space-bottom1"><div class="pad0y"><strong class="capitalize" keyline-all>Namespaces</strong></div><ul>
<li class="code"><a href="DateListConversions.html">DateListConversions</a></li><li class="code"><a href="DateListOperators.html">DateListOperators</a></li><li class="code"><a href="DateOperators.html">DateOperators</a></li></ul></div><h3>Drawing</h3>
<div class="space-bottom1"><div class="pad0y"><strong class="capitalize" keyline-all>Classes</strong></div><ul>
<li class="code"><a href="DragDetection.html">DragDetection</a></li><li class="code"><a href="Graphics.html">Graphics</a></li><li class="code"><a href="InputTextFieldHTML.html">InputTextFieldHTML</a></li><li class="code"><a href="TextBox.html">TextBox</a></li><li class="code"><a href="TextFieldHTML.html">TextFieldHTML</a></li></ul></div><div class="space-bottom1"><div class="pad0y"><strong class="capitalize" keyline-all>Namespaces</strong></div><ul>
<li class="code"><a href="CircleDraw.html">CircleDraw</a></li><li class="code"><a href="ColorsDraw.html">ColorsDraw</a></li><li class="code"><a href="Draw.html">Draw</a></li><li class="code"><a href="DrawTexts.html">DrawTexts</a></li><li class="code"><a href="DrawTextsAdvanced.html">DrawTextsAdvanced</a></li><li class="code"><a href="ListDraw.html">ListDraw</a></li><li class="code"><a href="NetworkDraw.html">NetworkDraw</a></li><li class="code"><a href="ObjectDraw.html">ObjectDraw</a></li><li class="code"><a href="StringDraw.html">StringDraw</a></li><li class="code"><a href="StringListDraw.html">StringListDraw</a></li><li class="code"><a href="TreeDraw.html">TreeDraw</a></li></ul></div><h3>Geometry</h3>
<div class="space-bottom1"><div class="pad0y"><strong class="capitalize" keyline-all>Classes</strong></div><ul>
<li class="code"><a href="Engine3D.html">Engine3D</a></li><li class="code"><a href="Point.html">Point</a></li><li class="code"><a href="Point3D.html">Point3D</a></li><li class="code"><a href="Polygon.html">Polygon</a></li><li class="code"><a href="Polygon3D.html">Polygon3D</a></li><li class="code"><a href="Polygon3DList.html">Polygon3DList</a></li><li class="code"><a href="PolygonList.html">PolygonList</a></li><li class="code"><a href="Rectangle.html">Rectangle</a></li><li class="code"><a href="RectangleList.html">RectangleList</a></li><li class="code"><a href="Space2D.html">Space2D</a></li></ul></div><div class="space-bottom1"><div class="pad0y"><strong class="capitalize" keyline-all>Namespaces</strong></div><ul>
<li class="code"><a href="GeometryConversions.html">GeometryConversions</a></li><li class="code"><a href="GeometryOperators.html">GeometryOperators</a></li><li class="code"><a href="PointOperators.html">PointOperators</a></li><li class="code"><a href="PolygonGenerators.html">PolygonGenerators</a></li><li class="code"><a href="PolygonListEncodings.html">PolygonListEncodings</a></li><li class="code"><a href="PolygonListOperators.html">PolygonListOperators</a></li><li class="code"><a href="PolygonOperators.html">PolygonOperators</a></li><li class="code"><a href="RectangleOperators.html">RectangleOperators</a></li></ul></div><h3>Networks</h3>
<div class="space-bottom1"><div class="pad0y"><strong class="capitalize" keyline-all>Classes</strong></div><ul>
<li class="code"><a href="Forces.html">Forces</a></li><li class="code"><a href="Network.html">Network</a></li><li class="code"><a href="Node.html">Node</a></li><li class="code"><a href="NodeList.html">NodeList</a></li><li class="code"><a href="Relation.html">Relation</a></li><li class="code"><a href="RelationList.html">RelationList</a></li><li class="code"><a href="Tree.html">Tree</a></li></ul></div><div class="space-bottom1"><div class="pad0y"><strong class="capitalize" keyline-all>Namespaces</strong></div><ul>
<li class="code"><a href="NetworkConversions.html">NetworkConversions</a></li><li class="code"><a href="NetworkEncodings.html">NetworkEncodings</a></li><li class="code"><a href="NetworkGenerators.html">NetworkGenerators</a></li><li class="code"><a href="NetworkOperators.html">NetworkOperators</a></li><li class="code"><a href="TreeConversions.html">TreeConversions</a></li><li class="code"><a href="TreeEncodings.html">TreeEncodings</a></li></ul></div><h3>Misc</h3>
<div class="space-bottom1"><div class="pad0y"><strong class="capitalize" keyline-all>Classes</strong></div><ul>
<li class="code"><a href="LoadEvent.html">LoadEvent</a></li><li class="code"><a href="MultiLoader.html">MultiLoader</a></li></ul></div><div class="space-bottom1"><div class="pad0y"><strong class="capitalize" keyline-all>Namespaces</strong></div><ul>
<li class="code"><a href="FastHtml.html">FastHtml</a></li></ul></div><h3>Strings</h3>
<div class="space-bottom1"><div class="pad0y"><strong class="capitalize" keyline-all>Classes</strong></div><ul>
<li class="code"><a href="StringList.html">StringList</a></li></ul></div><div class="space-bottom1"><div class="pad0y"><strong class="capitalize" keyline-all>Namespaces</strong></div><ul>
<li class="code"><a href="StringConversions.html">StringConversions</a></li><li class="code"><a href="StringListConversions.html">StringListConversions</a></li><li class="code"><a href="StringListOperators.html">StringListOperators</a></li><li class="code"><a href="StringOperators.html">StringOperators</a></li><li class="code"><a href="StringUtils.html">StringUtils</a></li></ul></div><h3>Functions</h3><ul><li class="small"><a href="global.html#getStructureLocalStorage">getStructureLocalStorage</a></li><li class="small"><a href="global.html#getStructureLocalStorageFromSeed">getStructureLocalStorageFromSeed</a></li><li class="small"><a href="global.html#setStructureLocalStorage">setStructureLocalStorage</a></li><li class="small"><a href="global.html#setStructureLocalStorageWithSeed">setStructureLocalStorageWithSeed</a></li></ul></div>
    </div>
  </div>
</div>
<div class='limiter margin2'>
    <div class='pad1y pad2x fill-white'>
      <div class='prose'>
        <div class='pad2y'>
          <h1 class='code'>Source: operators/lists/ListOperators.js</h1>
        </div>
        



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import List from "src/dataTypes/lists/List";
import ListConversions from "src/operators/lists/ListConversions";
import NumberTable from "src/dataTypes/numeric/NumberTable";
import Table from "src/dataTypes/lists/Table";
import NumberList from "src/dataTypes/numeric/NumberList";
import StringList from "src/dataTypes/strings/StringList";
import NodeList from "src/dataTypes/structures/lists/NodeList";
import StringOperators from "src/operators/strings/StringOperators";
import ColorOperators from "src/operators/graphic/ColorOperators";
import ColorScales from "src/operators/graphic/ColorScales";
import ColorListGenerators from "src/operators/graphic/ColorListGenerators";
import NumberOperators from "src/operators/numeric/NumberOperators";
import NumberListOperators from "src/operators/numeric/numberList/NumberListOperators";
import { typeOf, instantiate, instantiateWithSameType } from "src/tools/utils/code/ClassUtils";

/**
 * @classdesc List Operators
 *
 * @namespace
 * @category basics
 */
function ListOperators() {}
export default ListOperators;


/**
 * gets an element in a specified position from a List
 * @param  {List} list
 *
 * @param  {Number} index
 * @return {Object}
 * tags:
 */
ListOperators.getElement = function(list, index) {
  if(list == null) return null;
  index = index == null ? 0 : index % list.length;
  return list[index];
};

/**
 * multi-ouput operator that gives acces to individual elements
 * @param  {List} list
 *
 * @param  {Number} fromIndex (default 0)
 * @return {Object} first Object
 * @return {Object} second Object
 * @return {Object} third Object
 * @return {Object} fourth Object
 * @return {Object} fifth Object
 * @return {Object} sisxth Object
 * @return {Object} seventh Object
 * @return {Object} eight Object
 * @return {Object} ninth Object
 * @return {Object} tenth Object
 * tags:
 */
ListOperators.getFirstElements = function(list, fromIndex) {
  if(list == null) return null;

  fromIndex = fromIndex == null ? 0 : Number(fromIndex);

  return [
  {
    type: "Object",
    name: "first value",
    description: "first value",
    value: list[fromIndex + 0]
  },
  {
    type: "Object",
    name: "second value",
    description: "second value",
    value: list[fromIndex + 1]
  },
  {
    type: "Object",
    name: "third value",
    description: "third value",
    value: list[fromIndex + 2]
  },
  {
    type: "Object",
    name: "fourth value",
    description: "fourth value",
    value: list[fromIndex + 3]
  },
  {
    type: "Object",
    name: "fifth value",
    description: "fifth value",
    value: list[fromIndex + 4]
  },
  {
    type: "Object",
    name: "sixth value",
    description: "sixth value",
    value: list[fromIndex + 5]
  },
  {
    type: "Object",
    name: "seventh value",
    description: "seventh value",
    value: list[fromIndex + 6]
  },
  {
    type: "Object",
    name: "eight value",
    description: "eight value",
    value: list[fromIndex + 7]
  },
  {
    type: "Object",
    name: "ninth value",
    description: "ninth value",
    value: list[fromIndex + 8]
  },
  {
    type: "Object",
    name: "tenth value",
    description: "tenth value",
    value: list[fromIndex + 9]
  }];
};


/**
* check if two lists contain same elements
* @param {List} list0 first list
* @param {List} list1 second list
* @return {Boolean}
* tags:
*/
ListOperators.containSameElements = function(list0, list1) {
  if(list0==null || list1==null) return null;

  var l = list0.length;
  var i;

  if(l!=list1.length) return;

  for(i=0; i&lt;l; i++){
    if(list0[i]!=list1[i]) return false;
  }

  return true;
};


/**
 * first position of element in list (-1 if element doesn't belong to the list)
 * @param  {List} list
 * @param  {Object} element
 * @return {Number}
 * tags:
 */
ListOperators.indexOf = function(list, element) {
  return list.indexOf(element);
};

/**
 * concats lists
 * @param  {List} list0
 * @param  {List} list1
 *
 * @param  {List} list2
 * @param  {List} list3
 * @param  {List} list4
 * @return {List} list5
 * tags:
 */
ListOperators.concat = function() {
  if(arguments == null || arguments.length === 0 ||  arguments[0] == null) return null;
  if(arguments.length == 1) return arguments[0];

  var i;
  var list = arguments[0].concat(arguments[1]);
  for(i = 2; arguments[i]; i++) {
    list = list.concat(arguments[i]);
  }
  return list.getImproved();
};

/**
 * assembles a List
 * @param  {Object} argument0
 *
 * @param  {Object} argument1
 * @param  {Object} argument2
 * @param  {Object} argument3
 * @param  {Object} argument4
 * @return {List}
 * tags:
 */
ListOperators.assemble = function() {
  return List.fromArray(Array.prototype.slice.call(arguments, 0)).getImproved();
};



/**
 * returns a table with two Lists: words and occurrences
 * @param {List} list
 *
 * @param {Boolean} sortListsByOccurrences optional, true by default, common words first
 * @param {Boolean} consecutiveRepetitions optional false by default, if true only counts consecutive repetitions
 * @param {Number} optional limit, limits the size of the lists
 * @return {Table}
 * tags:count,toimprove,deprecated
 */
// ListOperators.countElementsRepetitionOnList = function(list, sortListsByOccurrences, consecutiveRepetitions, limit) { //transform this, use dictionary instead of indexOf !!!!!!!
//   if(list == null) return;

//   sortListsByOccurrences = sortListsByOccurrences == null ? true : sortListsByOccurrences;
//   consecutiveRepetitions = consecutiveRepetitions || false;
//   limit = limit == null ? 0 : limit;

//   var obj;
//   var elementList = instantiate(typeOf(list));
//   var numberList = new NumberList();
//   var index;
//   var i;

//   if(consecutiveRepetitions) {
//     if(list.length == 0) return null;
//     var previousElement = list[0];
//     elementList.push(previousElement);
//     numberList.push(1);
//     for(i = 1; i &lt; nElements; i++) {
//       obj = list[i];
//       if(obj == previousElement) {
//         numberList[numberList.length - 1] = numberList[numberList.length - 1] + 1;
//       } else {
//         elementList.push(obj);
//         numberList.push(1);
//         previousElement = obj;
//       }
//     }
//   } else {
//     for(i = 0; list[i] != null; i++){
//       obj = list[i];
//       index = elementList.indexOf(obj);
//       if(index != -1) {
//         numberList[index]++;
//       } else {
//         elementList.push(obj);
//         numberList.push(1);
//       }
//     }
//   }

//   if(elementList.type == "NumberList") {
//     var table = new NumberTable();
//   } else {
//     var table = new Table();
//   }
//   table[0] = elementList;
//   table[1] = numberList;

//   if(sortListsByOccurrences) {
//     table = TableOperators.sortListsByNumberList(table, numberList);
//   }

//   if(limit != 0 &amp;&amp; limit &lt; elementList.length) {
//     table[0] = table[0].splice(0, limit);
//     table[1] = table[1].splice(0, limit);
//   }

//   return table;
// };


/**
 * reverses a list
 * @param {List} list
 * @return {List}
 * tags:sorting
 */
ListOperators.reverse = function(list) {
  return list.getReversed();
};

/**
 * @todo write docs
 */
ListOperators.getBooleanDictionaryForList = function(list){
  if(list==null) return;

  var dictionary = {};
  list.forEach(function(element){
    dictionary[element] = true;
  });

  return dictionary;
};



/**
 * builds a dictionary that matches an element of a List with its index on the List (indexesDictionary[element] --> index)
 * it assumes there's no repetitions on the list (if that's not tha case the last index of the element will be delivered)
 * efficiently replaces indexOf
 * @param  {List} list
 * @return {Object}
 * tags:dictionary
 */
ListOperators.getSingleIndexDictionaryForList = function(list){
  if(list==null) return;

  var i;
  var l = list.length;

  var dictionary = {};
  for(i=0; i&lt;l; i++){
    dictionary[list[i]] = i;
  }

  return dictionary;
};

/**
 * builds a dictionary that matches an element of a List with all its indexes on the List (indexesDictionary[element] --> numberList of indexes of element on list)
 * if the list has no repeated elements, and a single is required per element, use ListOperators.getSingleIndexDictionaryForList
 * @param  {List} list
 * @return {Object}
 * tags:dictionary
 */
ListOperators.getIndexesDictionary = function(list){
  var indexesDictionary = {};

  list.forEach(function(element, i){
    if(indexesDictionary[element]==null) indexesDictionary[element]=new NumberList();
    indexesDictionary[element].push(i);
  });

  return indexesDictionary;
};

/**
 * @todo write docs
 */
ListOperators.getIndexesTable = function(list){
  var indexesTable = new Table();
  indexesTable[0] = new List();
  indexesTable[1] = new NumberTable();
  var indexesDictionary = {};
  var indexOnTable;

  list.forEach(function(element, i){
    indexOnTable = indexesDictionary[element];
    if(indexOnTable==null){
      indexesTable[0].push(element);
      indexesTable[1].push(new NumberList(i));
      indexesDictionary[element]=indexesTable[0].length-1;
    } else {
      indexesTable[1][indexOnTable].push(i);
    }
  });

  indexesTable[0] = indexesTable[0].getImproved();

  return indexesTable;
};

/**
 * builds a dictionar object (relational array) for a dictionar (table with two lists)
 * @param  {Table} dictionary table with two lists, typically without repetitions, elements of the second list being the 'translation' of the correspdonent on the first
 * @return {Object} relational array
 * tags:
 */
ListOperators.buildDictionaryObjectForDictionary = function(dictionary){
  if(dictionary==null || dictionary.length&lt;2) return;

  var dictionaryObject = {};

  dictionary[0].forEach(function(element, i){
    dictionaryObject[element] = dictionary[1][i];
  });

  return dictionaryObject;
};


/**
 * using a table with two columns as a dictionary (first list elements to be read, second list result elements), translates a list
 * @param  {List} list to transalte
 * @param  {Table} dictionary table with two lists
 *
 * @param {Object} nullElement element to place in case no translation is found
 * @return {List}
 * tags:
 */
ListOperators.translateWithDictionary = function(list, dictionary, nullElement) {
  if(list==null || dictionary==null || dictionary.length&lt;2) return;

  var dictionaryObject = ListOperators.buildDictionaryObjectForDictionary(dictionary);

  var newList = ListOperators.translateWithDictionaryObject(list, dictionaryObject, nullElement);

  newList.dictionaryObject = dictionaryObject;

  return newList;
};

/**
 * creates a new list that is a translation of a list using a dictionar object (a relation array)
 * @param  {List} list
 * @param  {Object} dictionaryObject
 *
 * @param  {Object} nullElement
 * @return {List}
 * tags:
 */
ListOperators.translateWithDictionaryObject = function(list, dictionaryObject, nullElement) {
  if(list==null || dictionaryObject==null) return;

  var newList = new List();
  var i;
  var nElements = list.length;

  for(i=0; i&lt;nElements; i++){
    newList[i] = dictionaryObject[list[i]];
  }
  // list.forEach(function(element, i) {
  //   newList[i] = dictionaryObject[element];
  // });

  if(nullElement!=null){
    var l = list.length;
    for(i=0; i&lt;l; i++){
      if(newList[i]==null) newList[i]=nullElement;
    }
  }
  newList.name = list.name;
  return newList.getImproved();
};


// ListOperators.getIndexesOfElements=function(list, elements){
// 	var numberList = new NumberList();
// 	var i;
// 	for(i=0; elements[i]!=null; i++){
// 		numberList[i] = list.indexOf(elements[i]);
// 	}
// 	return numberList;
// }


// ListOperators.countOccurrencesOnList=function(list){
// 	var occurrences=new NumberList();
// 	var nElements=list.length;
// 	for(var i=0; list[i]!=null; i++){
// 		occurrences.push(this.getIndexesOfElement(list,list[i]).length);
// 	}
// 	return occurrences;
// }


/**
 * @todo write docs
 */
ListOperators.sortListByNumberList = function(list, numberList, descending) {
  if(descending == null) descending = true;
  if(numberList.length === 0) return list;

  var pairs = [];
  var newList = instantiate(typeOf(list));
  var i;

  for(i = 0; list[i] != null; i++) {
    pairs.push([list[i], numberList[i],i]);
  }


  if(descending) {
    pairs.sort(function(a, b) {
      return a[1] &lt; b[1] ?  1 : a[1] > b[1] ? -1 : a[2] - b[2];
    });
  } else {
    pairs.sort(function(a, b) {
      return a[1] &lt; b[1] ? -1 : a[1] > b[1] ?  1 : a[2] - b[2];
    });
  }

  for(i = 0; pairs[i] != null; i++) {
    newList.push(pairs[i][0]);
  }
  newList.name = list.name;
  return newList;
};


/**
 * @todo write docs
 */
ListOperators.sortListByIndexes = function(list, indexedArray) {
  var newList = instantiate(typeOf(list));
  newList.name = list.name;
  var nElements = list.length;
  var i;
  for(i = 0; i &lt; nElements; i++) {
    newList.push(list[indexedArray[i]]);
  }
  return newList;
};


/**
 * @todo write docs
 */
ListOperators.concatWithoutRepetitions = function() {
  var l = arguments.length;
  if(l===0) return;
  if(l==1) return arguments[0];

  var i, j;
  var newList = arguments[0].clone();
  var newListBooleanDictionary = ListOperators.getBooleanDictionaryForList(newList);
  var addList;
  var nElements;
  for(i = 1; i &lt; l; i++) {
    addList = arguments[i];
    nElements = addList.length;
    for(j = 0; j &lt; nElements; j++) { // TODO Is the redefing of i intentional? &lt;----- !
      //if(newList.indexOf(addList[i]) == -1) newList.push(addList[i]);
      if(!newListBooleanDictionary[addList[j]]) newList.push(addList[j]);
    }
  }
  return newList.getImproved();
};

/**
 * builds a table: a list of sub-lists from the original list, each sub-list determined size subListsLength, and starting at certain indexes separated by step
 * @param  {List} list
 * @param  {Number} subListsLength length of each sub-list
 * @param  {Number} step slifing step
 * @param  {Number} finalizationMode&lt;br>0:all sub-Lists same length, doesn't cover the List&lt;br>1:last sub-List catches the last elements, with lesser length&lt;br>2:all lists same length, last sub-list migth contain elements from the beginning of the List
 * @return {Table}
 * tags:
 */
ListOperators.slidingWindowOnList = function(list, subListsLength, step, finalizationMode) {
  finalizationMode = finalizationMode || 0;
  var table = new Table();
  var newList;
  var nElements = list.length;
  var i;
  var j;

  step = Math.max(1, step);

  switch(finalizationMode) {
    case 0: //all sub-Lists same length, doesn't cover the List
      for(i = 0; i &lt; nElements; i += step) {
        if(i + subListsLength &lt;= nElements) {
          newList = new List();
          for(j = 0; j &lt; subListsLength; j++) {
            newList.push(list[i + j]);
          }
          table.push(newList.getImproved());
        }
      }
      break;
    case 1: //last sub-List catches the last elements, with lesser length
      for(i = 0; i &lt; nElements; i += step) {
        newList = new List();
        for(j = 0; j &lt; Math.min(subListsLength, nElements - i); j++) {
          newList.push(list[i + j]);
        }
        table.push(newList.getImproved());
      }
      break;
    case 2: //all lists same length, last sub-list migth contain elements from the beginning of the List
      for(i = 0; i &lt; nElements; i += step) {
        newList = new List();
        for(j = 0; j &lt; subListsLength; j++) {
          newList.push(list[(i + j) % nElements]);
        }
        table.push(newList.getImproved());
      }
      break;
  }

  return table.getImproved();
};

/**
 * @todo write docs
 */
ListOperators.getNewListForObjectType = function(object) {
  var newList = new List();
  newList[0] = object;
  return instantiateWithSameType(newList.getImproved());
};


/*
deprectaed, use intersection instead
 */
// ListOperators.listsIntersect = function(list0, list1) {
//   var list = list0.length &lt; list1.length ? list0 : list1;
//   var otherList = list0 == list ? list1 : list0;
//   for(var i = 0; list[i] != null; i++) {
//     if(otherList.indexOf(list[i]) != -1) return true;
//   }
//   return false;
// };


/**
 * creates a List that contains the union of two List (removing repetitions)
 * @param  {List} list0 first list
 * @param  {List} list1 second list
 * @return {List} the union of both Lists
 * tags:
 */
ListOperators.union = function(list0, list1) {//TODO:expand for more lists
  if(list0==null || list1==null) return;

  var union = new List();
  var l0 = list0.length;
  var l1 = list1.length;
  var i, k;

  if(list0.type=='NodeList' || list1.type=='NodeList'){
    union = new NodeList();
    union = list0.clone();
    for(i = 0; i&lt;l1; i++){
      if(list0.getNodeById(list1[i].id)==null) union.addNode(list1[i]);
    }
    return union;
  }

  var obj = {};

  for(i = 0; i&lt;l0; i++) obj[list0[i]] = list0[i];
  for(i = 0; i&lt;l1; i++) obj[list1[i]] = list1[i];
  
  for(k in obj) {
    //if(obj.hasOwnProperty(k)) // &lt;-- optional
    union.push(obj[k]);
  }
  return union.getImproved();
};

/**
 * creates a List that contains the intersection of two List (elements present in BOTH lists, result without repetions)
 * @param  {List} list0 first list
 * @param  {List} list1 second list
 * @return {List} intersection of both lists
 * tags:
 */
ListOperators.intersection = function(list0, list1) {//TODO:expand for more lists
  if(list0==null || list1==null) return;

  var intersection;
  //var l0  = list0.length;
  var l1  = list1.length;
  var i;
  var element;

  if(list0.type=="NodeList" &amp;&amp; list1.type=="NodeList"){
    intersection = new NodeList();

    list0.forEach(function(node){
      if(list1.getNodeById(node.id)){
        intersection.addNode(node);
      }
    });

    return intersection;
  }

  var dictionary =  ListOperators.getBooleanDictionaryForList(list0);//{};
  var dictionaryIntersected = {};
  
  intersection = new List();


  // list0.forEach(function(element){
  //   dictionary[element] = true;
  // });
  //list1.forEach(function(element){
  for(i=0; i&lt;l1; i++){
    element = list1[i];
    if(dictionary[element] &amp;&amp; dictionaryIntersected[element]==null){
      dictionaryIntersected[element]=true;
      intersection.push(element);
    }
  }
  //});
  return intersection.getImproved();
};


/**
 * returns the list of common elements between two lists (deprecated, use union instead)
 * @param  {List} list0
 * @param  {List} list1
 * @return {List}
 * tags:deprecated
 */
ListOperators.getCommonElements = function(list0, list1) {
  var nums = list0.type == 'NumberList' &amp;&amp; list1.type == 'NumberList';
  var strs = list0.type == 'StringList' &amp;&amp; list1.type == 'StringList';
  var newList = nums ? new NumberList() : (strs ? new StringList() : new List());

  var list = list0.length &lt; list1.length ? list0 : list1;
  var otherList = list0 == list ? list1 : list0;

  for(var i = 0; list[i] != null; i++) {
    if(otherList.indexOf(list[i]) != -1) newList.push(list[i]);
  }
  if(nums || strs) return newList;
  return newList.getImproved();
};




/**
 * creates a List that contains the union of two List (removing repetitions) (deprecated, use union instead)
 * @param  {List} list0
 * @param  {List} list A
 * @param  {List} list B
 *
 * @return {List} the union of both NumberLists
 */
// ListOperators.unionLists = function(x, y) {
//   // Borrowed from here: http://stackoverflow.com/questions/3629817/getting-a-union-of-two-arrays-in-javascript
//   var result;
//   if(x.type != x.type || (x.type != "StringList" &amp;&amp; x.type != "NumberList")) {
//     // To-do: call generic method here (not yet implemented)
//     //console.log( "ListOperators.unionLists for type '" + x.type + "' or '" + y.type + "' not yet implemented" );
//     return x.concat(y).getWithoutRepetitions();
//   }
//   else {
//     var obj = {};
//     var i;
//     for(i = x.length - 1; i >= 0; --i){
//       obj[x[i]] = x[i];
//     }
//     for(i = y.length - 1; i >= 0; --i){
//       obj[y[i]] = y[i];
//     }
//     result = x.type == "StringList" ? new StringList() : new NumberList();
//     for(var k in obj) {
//       if(obj.hasOwnProperty(k)) // &lt;-- optional
//         result.push(obj[k]);
//     }
//   }
//   return result;
// };



/**
 * calculates Jaccard index |list0 ∩ list1|/|list0 ∪ list1| see: https://en.wikipedia.org/wiki/Jaccard_index
 * @param  {List} list0
 * @param  {List} list1
 * @return {Number}
 * tags:
 */
ListOperators.jaccardIndex = function(list0, list1) {//TODO: see if this can be more efficient, maybe one idctionar for doing union and interstection at the same time
  return ListOperators.intersection(list0, list1).length/ListOperators.union(list0, list1).length;
};

/**
 * calculates Jaccard distance 1 - |list0 ∩ list1|/|list0 ∪ list1| see: https://en.wikipedia.org/wiki/Jaccard_index
 * @param  {List} list0
 * @param  {List} list1
 * @return {Number}
 * tags:
 */
ListOperators.jaccardDistance = function(list0, list1) {
  return 1 - ListOperators.jaccardIndex(list0, list1);
};



/**
 * aggregates values of a list using an aggregator list as reference
 *
 * @param  {List} aggregatorList aggregator list that typically contains several repeated elements
 * @param  {List} toAggregateList list of elements that will be aggregated
 * @param  {Number} mode aggregation modes:&lt;br>0:first element&lt;br>1:count (default)&lt;br>2:sum&lt;br>3:average&lt;br>4:min&lt;br>5:max&lt;br>6:standard deviation&lt;br>7:enlist (creates a list of elements)&lt;br>8:last element&lt;br>9:most common element&lt;br>10:random element&lt;br>11:indexes&lt;br>12:count non repeated elements&lt;br>13:enlist non repeated elements&lt;br>14:concat elements (string)&lt;br>15:concat non-repeated elements
 * @param  {Table} indexesTable optional already calculated table of indexes of elements on the aggregator list (if didn't provided, the method calculates it)
 * @return {Table} contains a list with non repeated elements on the first list, and the aggregated elements on a second list
 * tags:
 */
ListOperators.aggregateList = function(aggregatorList, toAggregateList, mode, indexesTable){
  if(aggregatorList==null || toAggregateList==null) return null;
  var table = new Table();

  if(indexesTable==null) indexesTable = ListOperators.getIndexesTable(aggregatorList);

  if(mode==11) return indexesTable;

  table[0] = indexesTable[0];

  if(mode===0 &amp;&amp; aggregatorList==toAggregateList){
    table[1] = indexesTable[0];
    return table;
  }

  mode = mode==null?0:mode;

  var list;
  var elementsTable;

  switch(mode){
    case 0://first element
      table[1] = new List();
      indexesTable[1].forEach(function(indexes){
        table[1].push(toAggregateList[indexes[0]]);
      });
      table[1] = table[1].getImproved();
      return table;
    case 1://count
      table[1] = new NumberList();
      indexesTable[1].forEach(function(indexes){
        table[1].push(indexes.length);
      });
      return table;
    case 2://sum
    case 3://average
      var sum;
      table[1] = new NumberList();
      indexesTable[1].forEach(function(indexes){
        sum = 0;
        indexes.forEach(function(index){
          sum+=toAggregateList[index];
        });
        if(mode==3) sum/=indexes.length;
        table[1].push(sum);
      });
      return table;
    case 4://min
      var min;
      table[1] = new NumberList();
      indexesTable[1].forEach(function(indexes){
        min = 99999999999;
        indexes.forEach(function(index){
          min=Math.min(min, toAggregateList[index]);
        });
        table[1].push(min);
      });
      return table;
    case 5://max
      var max;
      table[1] = new NumberList();
      indexesTable[1].forEach(function(indexes){
        max = -99999999999;
        indexes.forEach(function(index){
          max=Math.max(max, toAggregateList[index]);
        });
        table[1].push(max);
      });
      return table;
    case 6://standard deviation
      var average;
      table = ListOperators.aggregateList(aggregatorList, toAggregateList, 3, indexesTable);
      indexesTable[1].forEach(function(indexes, i){
        sum = 0;
        average = table[1][i];
        indexes.forEach(function(index){
          sum += Math.pow(toAggregateList[index] - average, 2);
        });
        table[1][i] = Math.sqrt(sum/indexes.length);
      });
      return table;
    case 7://enlist
      table[1] = new Table();
      indexesTable[1].forEach(function(indexes){
        list = new List();
        table[1].push(list);
        indexes.forEach(function(index){
          list.push(toAggregateList[index]);
        });
        list = list.getImproved();
      });
      return table.getImproved();
    case 8://last element
      table[1] = new List();
      indexesTable[1].forEach(function(indexes){
        table[1].push(toAggregateList[indexes[indexes.length-1]]);
      });
      table[1] = table[1].getImproved();
      return table;
    case 9://most common
      table[1] = new List();
      elementsTable = ListOperators.aggregateList(aggregatorList, toAggregateList, 7, indexesTable);
      elementsTable[1].forEach(function(elements){
        table[1].push(elements.getMostRepeatedElement());
      });
      table[1] = table[1].getImproved();
      return table;
    case 10://random
      table[1] = new List();
      indexesTable[1].forEach(function(indexes){
        table[1].push( toAggregateList[indexes[ Math.floor(Math.random()*indexes.length) ]] );
      });
      table[1] = table[1].getImproved();
      return table;
    case 11://indexes (returned previosuly)
      break;
    case 12://count non repeated
      table[1] = new NumberList();
      elementsTable = ListOperators.aggregateList(aggregatorList, toAggregateList, 7, indexesTable);
      elementsTable[1].forEach(function(elements){
        table[1].push(elements.getWithoutRepetitions().length);
      });
      return table;
    case 13://enlist non repeated
      table[1] = new List();
      elementsTable = ListOperators.aggregateList(aggregatorList, toAggregateList, 7, indexesTable);
      elementsTable[1].forEach(function(elements){
        table[1].push(elements.getWithoutRepetitions());
      });
      table[1] = table[1].getImproved();
      return table;
    case 14://concat string
      table[1] = new StringList();
      elementsTable = ListOperators.aggregateList(aggregatorList, toAggregateList, 7, indexesTable);
      elementsTable[1].forEach(function(elements){
        table[1].push( elements.join(', ') );
      });
      return table;
    case 15://concat string non repeated
      table[1] = new StringList();
      elementsTable = ListOperators.aggregateList(aggregatorList, toAggregateList, 7, indexesTable);
      elementsTable[1].forEach(function(elements){
        table[1].push( elements.getWithoutRepetitions().join(', ') );
      });
      return table;
  }

  return null;
};

/**
 * Analyses wether two lists are categorical identical, one is subcategorical to the other, or there's no relation
 * @param  {List} list0
 * @param  {List} list1
 * @return {Number} 0:no relation, 1:categorical identical, 2:list0 subcategorical to list1, 3:list1 subcategorical to list0
 * tags:
 */
ListOperators.subCategoricalAnalysis = function(list0, list1){
  if(list0==null || list1==null) return;

  var dictionary = {};
  var element, projection;
  var i;
  var list0SubCategorical = true;
  for(i=0; list0[i]!=null; i++){
    element = list0[i];
    projection = dictionary[element];
    if(projection==null){
      dictionary[element] = list1[i];
    } else if(projection!=list1[i]){
      list0SubCategorical = false;
      break;
    }
  }

  dictionary = {};
  var list1SubCategorical = true;
  for(i=0; list1[i]!=null; i++){
    element = list1[i];
    projection = dictionary[element];
    if(projection==null){
      dictionary[element] = list0[i];
    } else if(projection!=list0[i]){
      list1SubCategorical = false;
      break;
    }
  }

  if(list1SubCategorical &amp;&amp; list0SubCategorical) return 1;
  if(list0SubCategorical) return 2;
  if(list1SubCategorical) return 3;
  return 0;
};

/**
 * calculates de entropy of a list, properties _mostRepresentedValue and _biggestProbability are added to the list
 * @param  {List} list with repeated elements (actegorical list)
 *
 * @param {Object} valueFollowing if a value is provided, the property _P_valueFollowing will be added to the list, with proportion of that value in the list
 * @param {Table} freqTable for saving time, in case the frequency table with sorted elements has been already calculated (with list.getFrequenciesTable(true))
 * @return {Number}
 * tags:statistics
 */
ListOperators.getListEntropy = function(list, valueFollowing, freqTable) {
  if(list == null) return;

  if(list.length &lt; 2) {
    if(list.length == 1) {
      list._mostRepresentedValue = list[0];
      list._biggestProbability = 1;
      if(valueFollowing != null) list._P_valueFollowing = list[0] == valueFollowing ? 1 : 0;
    } else {
      if(valueFollowing != null) list._P_valueFollowing = 0;
    }
    return 0;
  }

  if(freqTable==null) freqTable = list.getFrequenciesTable(true);// ListOperators.countElementsRepetitionOnList(list, true);

  list._mostRepresentedValue = freqTable[0][0];
  var N = list.length;
  list._biggestProbability = freqTable[1][0] / N;
  if(freqTable[0].length == 1) {
    list._P_valueFollowing = list[0] == valueFollowing ? 1 : 0;
    return 0;
  }
  var entropy = 0;

  var norm = Math.log(freqTable[0].length);
  freqTable[1].forEach(function(val) {
    entropy -= (val / N) * Math.log(val / N) / norm;
  });

  if(valueFollowing != null) {
    var index = freqTable[0].indexOf(valueFollowing);
    list._P_valueFollowing = index == -1 ? 0 : freqTable[1][index] / N;
  }
  return entropy;
};


/**
 * measures how much a feature decreases entropy when segmenting by its values by a supervised variable
 * @param  {List} feature
 * @param  {List} supervised
 * @return {Number}
 * tags:ds
 */
ListOperators.getInformationGain = function(feature, supervised) {
  if(feature == null || supervised == null || feature.length != supervised.length) return null;

  var ig = ListOperators.getListEntropy(supervised);
  var childrenObject = {};
  var childrenLists = [];
  var N = feature.length;

  feature.forEach(function(element, i) {
    if(childrenObject[element] == null) {
      childrenObject[element] = new List();
      childrenLists.push(childrenObject[element]);
    }
    childrenObject[element].push(supervised[i]);
  });

  childrenLists.forEach(function(cl) {
    ig -= (cl.length / N) * ListOperators.getListEntropy(cl);
  });

  return ig;
};

/**
 * @todo write docs
 */
ListOperators.getInformationGainAnalysis = function(feature, supervised) {
  if(feature == null || supervised == null || feature.length != supervised.length) return null;

  var ig = ListOperators.getListEntropy(supervised);
  var childrenObject = {};
  var childrenLists = [];
  var N = feature.length;
  var entropy;
  var sets = new List();

  feature.forEach(function(element, i) {
    if(childrenObject[element] == null) {
      childrenObject[element] = new List();
      childrenLists.push(childrenObject[element]);
    }
    childrenObject[element].push(supervised[i]);
  });

  childrenLists.forEach(function(cl) {
    entropy = ListOperators.getListEntropy(cl);
    ig -= (cl.length / N) * entropy;

    sets.push({
      children: cl,
      entropy: entropy,
      infoGain: ig
    });
  });

  return sets;
};


/**
 * Takes a List and returns its elements grouped by identic value. Each list in the table is assigned a "valProperty" value which is used for sorting
 * @param  {List} list of elements to group
 * @param  {Boolean} whether the results are to be sorted or not
 * @param  {Number} mode: 0 for returning original values, 1 for indices in original list
 *
 * @param  {Boolean} fillBlanks: whether to fill missing slots or not (if data is sequential)
 * @return {Table}
 * tags:dani
 */
ListOperators.groupElements = function(list, sortedByValue, mode, fillBlanks) {
  if(!list)
    return;
  var result = ListOperators._groupElements_Base(list, null, sortedByValue, mode, fillBlanks);
  return result;
};


/**
 * Takes a List and returns its elements grouped by identic value. Each list in the table is assigned a "valProperty" value which is used for sorting
 * @param  {List} list of elements to group
 * @param  {String} name of the property to be used for grouping
 * @param  {Boolean} wether the results are to be sorted or not
 * @param  {Number} mode: 0 for returning original values, 1 for indices in original list
 *
 * @param  {Boolean} fillBlanks: whether to fill missing slots or not (if data is sequential)
 * @return {Table}
 * tags:dani
 */
ListOperators.groupElementsByPropertyValue = function(list, propertyName, sortedByValue, mode, fillBlanks) {
  if(!list)
    return;
  var result = ListOperators._groupElements_Base(list, propertyName, sortedByValue, mode, fillBlanks);
  return result;
};



/**
 * @ignore
 */
ListOperators._groupElements_Base = function(list, propertyName, sortedByValue, mode, fillBlanks) {
  if(!list)
    return;
  if(mode == undefined){
    mode = 0;
  }
  var resultOb = {};
  var resultTable = new Table();
  var pValue, item, minValue, maxValue, i;
  for(i = 0; i &lt; list.length; i++) {
    item = list[i];
    pValue = propertyName == undefined ? item : item[propertyName];
    if(resultOb[pValue] === undefined) {
      resultOb[pValue] = new List();
      resultOb[pValue].name = pValue;
      resultOb[pValue].valProperty = pValue;
      resultTable.push(resultOb[pValue]);
    }
    if(mode === 0)
      resultOb[pValue].push(item);
    else if(mode == 1)
      resultOb[pValue].push(i);
    // Update boundaries
    if(minValue === undefined || pValue &lt; minValue) {
      minValue = pValue;
    }
    if(maxValue === undefined || pValue > maxValue) {
      maxValue = pValue;
    }
  }

  // Fill the blanks
  if(fillBlanks) {
    var numBlanks = 0;
    for(i = minValue; i &lt; maxValue; i++) {
      if(resultOb[i] === undefined) {
        resultOb[i] = new List();
        resultOb[i].name = i;
        resultOb[i].valProperty = i;
        resultTable.push(resultOb[i]);
        numBlanks++;
      }
    }
    //console.log("numBlanks: ", numBlanks)
  }

  // To-do: looks like getSortedByProperty is removing the valProperty from the objects
  if(sortedByValue)
    resultTable = resultTable.getSortedByProperty("name"); // "valProperty"

  return resultTable;

};

/**
 * returns a string representing list
 *
 * @param  {List} list
 * @param  {Number} level
 *
 */
ListOperators.getReport = function(list, level) { //TODO:complete
  var ident = "\n" + (level > 0 ? StringOperators.repeatString("  ", level) : "");
  var text = level > 0 ? (ident + "////report of instance of List////") : "///////////report of instance of List//////////";

  var length = list.length;
  var i;

  text += ident + "name: " + list.name;
  text += ident + "type: " + list.type;

  if(length === 0) {
    text += ident + "single element: [" + list[0] + "]";
    return text;
  } else {
    text += ident + "length: " + length;
    text += ident + "first element: [" + list[0] + "]";
  }

  switch(list.type) {
    case "NumberList":
      var min = list.getMin();
      var max = list.getMax();
      list.min = min;
      list.max = max;
      var average = list.getAverage();//(min + max) * 0.5;
      list.average = average;
      text += ident + "min: " + min;
      text += ident + "max: " + max;
      text += ident + "average: " + average;
      if(length &lt; 101) {
        text += ident + "numbers: " + list.join(", ");
      }
      break;
    case "StringList":
    case "List":
    case "ColorList":
      var freqTable = list.getFrequenciesTable(true);
      list._freqTable = freqTable;
      text += ident + "number of different elements: " + freqTable[0].length;
      if(freqTable[0].length &lt; 10) {
        text += ident + "elements frequency:";
      } else {
        text += ident + "some elements frequency:";
      }

      for(i = 0; freqTable[0][i] != null &amp;&amp; i &lt; 10; i++) {
        text += ident + "  [" + String(freqTable[0][i]) + "]: " + freqTable[1][i];
      }

      var joined;
      if(list.type == "List") {
        joined = list.join("], [");
      } else {
        joined = ListConversions.toStringList(list).join("], [");
      }

      if(joined.length &lt; 2000) text += ident + "strings: [" + joined + "]";
      break;

  }

  ///add ideas to: analyze, visualize


  return text;
};


ListOperators.getReportHtml = function(list, level) { //TODO:complete
  var ident = "&lt;br>" + (level > 0 ? StringOperators.repeatString("&amp;nbsp", level) : "");
  var text =  level > 0 ? "" : "&lt;b>&lt;font style=\"font-size:18px\">list report&lt;/f>&lt;/b>";

  var length = list.length;
  var i;

  if(list.name){
    text += ident + "name: &lt;b>" + list.name + "&lt;/b>";
  } else {
    text += ident + "&lt;i>no name&lt;/i>";
  }
  text += ident + "type: &lt;b>" + list.type + "&lt;/b>";

  if(length === 0) {
    text += ident + "single element: [&lt;b>" + list[0] + "&lt;/b>]";
    return text;
  } else {
    text += ident + "length: &lt;b>" + length + "&lt;/b>";
    text += ident + "first element: [&lt;b>" + list[0] + "&lt;/b>]";
  }

  switch(list.type) {
    case "NumberList":
      var min = 9999999;
      var max = -9999999;
      var average = 0;
      var shorten = new NumberList();
      var index = 0;
      var accumsum = 0;
      var maxAccumsum = -99999;
      var sizeAccum = Math.max(Math.floor(list.length/50), 1);

      list.forEach(function(val){
        min = Math.min(min, val);
        max = Math.max(max, val);
        average += val;
        accumsum += val;
        index++;
        if(index==sizeAccum){
          accumsum /= index;
          maxAccumsum = Math.max(maxAccumsum, accumsum);
          shorten.push(accumsum);
          accumsum=0;
          index=0;
        }
      });
      if(index !== 0){
          accumsum /=index;
          maxAccumsum = Math.max(maxAccumsum, accumsum);
          shorten.push(accumsum);
      }

      shorten = shorten.factor(1/maxAccumsum);

      average /= list.length;

      list.min = min;
      list.max = max;
      list.average = average;
      text += ident + "min: &lt;b>" + min + "&lt;/b>";
      text += ident + "max: &lt;b>" + max + "&lt;/b>";
      text += ident + "average: &lt;b>" + average + "&lt;/b>";
      if(length &lt; 101) {
        text += ident + "numbers: &lt;b>" + list.join("&lt;/b>, &lt;b>") + "&lt;/b>";
      }
      text += ident;
      for(i=0; shorten[i]!=null; i++){
        text += "&lt;font style=\"font-size:7px\">&lt;font color=\""+ColorOperators.colorStringToHEX(ColorScales.grayToOrange(shorten[i]))+"\">█&lt;/f>&lt;/f>";
      }
      break;
    case "StringList":
    case "List":
    case "ColorList":
      var freqTable = list.getFrequenciesTable(true);
      list._freqTable = freqTable;
      var catColors = ColorListGenerators.createCategoricalColors(2, freqTable[0].length);

      text += ident + "entropy: &lt;b>" + NumberOperators.numberToString(ListOperators.getListEntropy(list, null, freqTable), 4) + "&lt;/b>";

      text += ident + "number of different elements: &lt;b>" + freqTable[0].length + "&lt;/b>";
      if(freqTable[0].length &lt; 10) {
        text += ident + "elements frequency:";
      } else {
        text += ident + "some elements frequency:";
      }

      for(i = 0; freqTable[0][i] != null &amp;&amp; i &lt; 10; i++) {
        text += ident + "  [&lt;b>" + String(freqTable[0][i]) + "&lt;/b>]: &lt;font style=\"font-size:10px\">&lt;b>&lt;font color=\""+ColorOperators.colorStringToHEX(catColors[i])+"\">" + freqTable[1][i] + "&lt;/f>&lt;/b>&lt;/f>";
      }

      var joined;
      if(list.type == "List") {
        joined = list.join("], [");
      } else {
        joined = ListConversions.toStringList(list).join("], [");
      }

      if(joined.length &lt; 2000) text += ident + "contents: [" + joined + "]";

      var weights = NumberListOperators.normalizedToSum(freqTable[1]);

      var bars = StringOperators.createsCategoricalColorsBlocksHtml(weights, 55, catColors);
      text += ident;
      text += "&lt;font style=\"font-size:7px\">"+bars+"&lt;/f>";

      break;
  }


  ///add ideas to: analyze, visualize
  return text;
};
</code></pre>
        </article>
    </section>




      </div>
    </div>
    <div class='quiet small center pad1y'>
    </div>
  </div>
  <script src="http://code.jquery.com/jquery-1.11.3.min.js"></script>
  <script src="scripts/filter.js"></script>
  <script src="scripts/prettify/prettify.js"></script>
  <script src="scripts/clipboard/clipboard.js"></script>
  <script type="text/javascript">
      var copyCodes = new Clipboard('.copyCode');
  </script>
</body>
</html>

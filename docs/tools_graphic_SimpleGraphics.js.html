<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Moebio Framework: Source: tools/graphic/SimpleGraphics.js</title>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:700italic,400,700' rel='stylesheet' type='text/css'>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/style.css">
</head>

<body onload="prettyPrint()">

<div class='hide-mobile pin-left pint-top pin-bottom col2 quiet-scroll scroll-styled fixed'>

  <div class='clearfix fill-background dark center'>
    <div class='inline pad2y'>
      <a href="../">Moebio Platform</a> / <a href="index.html">Docs</a>
    </div>
  </div>
  <div class='pad1 small'>
    <div class="filter-block clearfix">
      <input type="text" id="filter-input" placeholder="Type to filter">
      <a href="#" id="clear-filter-button">x</a>
    </div>
    <div class='side'>
      <h3></h3><ul><div class="space-bottom1"><div class="pad0y"><strong class="capitalize" keyline-all></strong></div><ul><li class="code"><a href="module-Global.html">Global</a></li><li class="code"><a href="module-SimpleGraphics.html">SimpleGraphics</a></li></ul></div></ul><h3>Numbers</h3>
<div class="space-bottom1"><div class="pad0y"><strong class="capitalize" keyline-all>Classes</strong></div><ul>
<li class="code"><a href="Axis2D.html">Axis2D</a></li><li class="code"><a href="Interval.html">Interval</a></li><li class="code"><a href="Matrix.html">Matrix</a></li><li class="code"><a href="NumberList.html">NumberList</a></li><li class="code"><a href="NumberTable.html">NumberTable</a></li></ul></div><div class="space-bottom1"><div class="pad0y"><strong class="capitalize" keyline-all>Namespaces</strong></div><ul>
<li class="code"><a href="IntervalListOperators.html">IntervalListOperators</a></li><li class="code"><a href="IntervalTableOperators.html">IntervalTableOperators</a></li><li class="code"><a href="NumberListGenerators.html">NumberListGenerators</a></li><li class="code"><a href="NumberListOperators.html">NumberListOperators</a></li><li class="code"><a href="NumberOperators.html">NumberOperators</a></li><li class="code"><a href="NumberTableConversions.html">NumberTableConversions</a></li><li class="code"><a href="NumberTableFlowOperators.html">NumberTableFlowOperators</a></li><li class="code"><a href="NumberTableOperators.html">NumberTableOperators</a></li></ul></div><h3>Colors</h3>
<div class="space-bottom1"><div class="pad0y"><strong class="capitalize" keyline-all>Classes</strong></div><ul>
<li class="code"><a href="ColorList.html">ColorList</a></li><li class="code"><a href="ColorScale.html">ColorScale</a></li></ul></div><div class="space-bottom1"><div class="pad0y"><strong class="capitalize" keyline-all>Namespaces</strong></div><ul>
<li class="code"><a href="ColorGenerators.html">ColorGenerators</a></li><li class="code"><a href="ColorListGenerators.html">ColorListGenerators</a></li><li class="code"><a href="ColorListOperators.html">ColorListOperators</a></li><li class="code"><a href="ColorOperators.html">ColorOperators</a></li><li class="code"><a href="ColorScaleGenerators.html">ColorScaleGenerators</a></li><li class="code"><a href="ColorScales.html">ColorScales</a></li></ul></div><h3>Geo</h3>
<div class="space-bottom1"><div class="pad0y"><strong class="capitalize" keyline-all>Classes</strong></div><ul>
<li class="code"><a href="Country.html">Country</a></li><li class="code"><a href="CountryList.html">CountryList</a></li></ul></div><div class="space-bottom1"><div class="pad0y"><strong class="capitalize" keyline-all>Namespaces</strong></div><ul>
<li class="code"><a href="CountryListOperators.html">CountryListOperators</a></li><li class="code"><a href="CountryOperators.html">CountryOperators</a></li><li class="code"><a href="GeoOperators.html">GeoOperators</a></li></ul></div><h3>Basics</h3>
<div class="space-bottom1"><div class="pad0y"><strong class="capitalize" keyline-all>Classes</strong></div><ul>
<li class="code"><a href="DataModel.html">DataModel</a></li><li class="code"><a href="List.html">List</a></li><li class="code"><a href="Table.html">Table</a></li></ul></div><div class="space-bottom1"><div class="pad0y"><strong class="capitalize" keyline-all>Namespaces</strong></div><ul>
<li class="code"><a href="CanvasAndContext.html">CanvasAndContext</a></li><li class="code"><a href="FastHtml.html">FastHtml</a></li><li class="code"><a href="ListGenerators.html">ListGenerators</a></li><li class="code"><a href="ListOperators.html">ListOperators</a></li><li class="code"><a href="MatrixGenerators.html">MatrixGenerators</a></li><li class="code"><a href="ObjectConversions.html">ObjectConversions</a></li><li class="code"><a href="ObjectOperators.html">ObjectOperators</a></li><li class="code"><a href="TableConversions.html">TableConversions</a></li><li class="code"><a href="TableEncodings.html">TableEncodings</a></li><li class="code"><a href="TableGenerators.html">TableGenerators</a></li><li class="code"><a href="TableOperators.html">TableOperators</a></li></ul></div><h3>Dates</h3>
<div class="space-bottom1"><div class="pad0y"><strong class="capitalize" keyline-all>Classes</strong></div><ul>
<li class="code"><a href="DateAxis.html">DateAxis</a></li><li class="code"><a href="DateInterval.html">DateInterval</a></li><li class="code"><a href="DateList.html">DateList</a></li></ul></div><div class="space-bottom1"><div class="pad0y"><strong class="capitalize" keyline-all>Namespaces</strong></div><ul>
<li class="code"><a href="DateListOperators.html">DateListOperators</a></li><li class="code"><a href="DateOperators.html">DateOperators</a></li></ul></div><h3>Interactions</h3>
<div class="space-bottom1"><div class="pad0y"><strong class="capitalize" keyline-all>Classes</strong></div><ul>
<li class="code"><a href="DragDetection.html">DragDetection</a></li></ul></div><h3>Geometry</h3>
<div class="space-bottom1"><div class="pad0y"><strong class="capitalize" keyline-all>Classes</strong></div><ul>
<li class="code"><a href="Engine3D.html">Engine3D</a></li><li class="code"><a href="Point.html">Point</a></li><li class="code"><a href="Point3D.html">Point3D</a></li><li class="code"><a href="Polygon.html">Polygon</a></li><li class="code"><a href="Polygon3D.html">Polygon3D</a></li><li class="code"><a href="Polygon3DList.html">Polygon3DList</a></li><li class="code"><a href="PolygonList.html">PolygonList</a></li><li class="code"><a href="Rectangle.html">Rectangle</a></li><li class="code"><a href="RectangleList.html">RectangleList</a></li><li class="code"><a href="Space2D.html">Space2D</a></li></ul></div><div class="space-bottom1"><div class="pad0y"><strong class="capitalize" keyline-all>Namespaces</strong></div><ul>
<li class="code"><a href="Draw.html">Draw</a></li><li class="code"><a href="GeometryConvertions.html">GeometryConvertions</a></li><li class="code"><a href="GeometryOperators.html">GeometryOperators</a></li><li class="code"><a href="PointOperators.html">PointOperators</a></li><li class="code"><a href="PolygonGenerators.html">PolygonGenerators</a></li><li class="code"><a href="PolygonListEncodings.html">PolygonListEncodings</a></li><li class="code"><a href="PolygonListOperators.html">PolygonListOperators</a></li><li class="code"><a href="PolygonOperators.html">PolygonOperators</a></li><li class="code"><a href="RectangleOperators.html">RectangleOperators</a></li></ul></div><h3>Networks</h3>
<div class="space-bottom1"><div class="pad0y"><strong class="capitalize" keyline-all>Classes</strong></div><ul>
<li class="code"><a href="Forces.html">Forces</a></li><li class="code"><a href="Network.html">Network</a></li><li class="code"><a href="Node.html">Node</a></li><li class="code"><a href="NodeList.html">NodeList</a></li><li class="code"><a href="Relation.html">Relation</a></li><li class="code"><a href="RelationList.html">RelationList</a></li><li class="code"><a href="Tree.html">Tree</a></li></ul></div><div class="space-bottom1"><div class="pad0y"><strong class="capitalize" keyline-all>Namespaces</strong></div><ul>
<li class="code"><a href="NetworkConvertions.html">NetworkConvertions</a></li><li class="code"><a href="NetworkDraw.html">NetworkDraw</a></li><li class="code"><a href="NetworkEncodings.html">NetworkEncodings</a></li><li class="code"><a href="NetworkGenerators.html">NetworkGenerators</a></li><li class="code"><a href="NetworkOperators.html">NetworkOperators</a></li><li class="code"><a href="TreeConvertions.html">TreeConvertions</a></li><li class="code"><a href="TreeDraw.html">TreeDraw</a></li><li class="code"><a href="TreeEncodings.html">TreeEncodings</a></li></ul></div><h3>Strings</h3>
<div class="space-bottom1"><div class="pad0y"><strong class="capitalize" keyline-all>Classes</strong></div><ul>
<li class="code"><a href="InputTextFieldHTML.html">InputTextFieldHTML</a></li><li class="code"><a href="StringList.html">StringList</a></li><li class="code"><a href="TextBox.html">TextBox</a></li><li class="code"><a href="TextFieldHTML.html">TextFieldHTML</a></li></ul></div><div class="space-bottom1"><div class="pad0y"><strong class="capitalize" keyline-all>Namespaces</strong></div><ul>
<li class="code"><a href="DrawTexts.html">DrawTexts</a></li><li class="code"><a href="DrawTextsAdvanced.html">DrawTextsAdvanced</a></li><li class="code"><a href="StringConversions.html">StringConversions</a></li><li class="code"><a href="StringListOperators.html">StringListOperators</a></li><li class="code"><a href="StringListVisOperators.html">StringListVisOperators</a></li><li class="code"><a href="StringOperators.html">StringOperators</a></li><li class="code"><a href="StringUtils.html">StringUtils</a></li></ul></div><h3>Misc</h3>
<div class="space-bottom1"><div class="pad0y"><strong class="capitalize" keyline-all>Classes</strong></div><ul>
<li class="code"><a href="LoadEvent.html">LoadEvent</a></li><li class="code"><a href="MultiLoader.html">MultiLoader</a></li></ul></div><h3>Functions</h3><ul><li class="small"><a href="global.html#Triangle">Triangle</a></li></ul></div>
    </div>
  </div>
</div>
<div class='limiter margin2'>
    <div class='pad1y pad2x fill-white'>
      <div class='prose'>
        <div class='pad2y'>
          <h1 class='code'>Source: tools/graphic/SimpleGraphics.js</h1>
        </div>
        



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { context, TwoPi, mX, mY, mP, canvas, HalfPi, cW, cH } from 'src/Global';
import Polygon from 'src/dataStructures/geometry/Polygon';
import Point from 'src/dataStructures/geometry/Point';
import GeometryOperators from 'src/operators/geometry/GeometryOperators';
import Rectangle from 'src/dataStructures/geometry/Rectangle';

/**
 * @module SimpleGraphics
 *
 * @classdesc Graphic and text methods globally accesible
 * that work with context.
 */



//drawing

/**
 * Draws a filled in Rectangle.
 * Fill color is expected to be set using {@link setFill}.
 *
 * @param {Number} x X position of upper-left corner of Rectangle.
 * @param {Number} y Y position of upper-left corner of Rectangle.
 * @param {Number} width Width of Rectangle in pixels.
 * @param {Number} height Height of Rectangle in pixels.
 * @example
 * setFill('steelblue');
 * fRect(10, 10, 40, 40);
 *
 */
export function fRect(x, y, width, height) {
  if(typeof x != 'number') {
    y = x.y;
    width = x.width;
    height = x.height;
    x = x.x;
  }
  context.fillRect(x, y, width, height);
}

/**
 * Draws a stroked Rectangle - showing just an outline.
 * Stroke color is expected to be set using {@link setStroke}.
 *
 * @param {Number} x X position of upper-left corner of Rectangle.
 * @param {Number} y Y position of upper-left corner of Rectangle.
 * @param {Number} width Width of Rectangle in pixels.
 * @param {Number} height Height of Rectangle in pixels.
 * @example
 * setStroke('orange');
 * sRect(10, 10, 40, 40);
 *
 */
export function sRect(x, y, width, height) {
  if(typeof x != 'number') {
    y = x.y;
    width = x.width;
    height = x.height;
    x = x.x;
  }
  context.strokeRect(x, y, width, height);
}

/**
 * Draws a filled and stroked Rectangle.
 * Fill color is expected to be set using {@link setFill}.
 * Stroke color is expected to be set using {@link setStroke}.
 *
 * @param {Number} x X position of upper-left corner of Rectangle.
 * @param {Number} y Y position of upper-left corner of Rectangle.
 * @param {Number} width Width of Rectangle in pixels.
 * @param {Number} height Height of Rectangle in pixels.
 * @example
 * setFill('steelblue');
 * setStroke('orange');
 * fsRect(10, 10, 40, 40);
 *
 */
export function fsRect(x, y, width, height) {
  if(typeof x != 'number') {
    y = x.y;
    width = x.width;
    height = x.height;
    x = x.x;
  }
  context.fillRect(x, y, width, height);
  context.strokeRect(x, y, width, height);
}

/**
 * Draws a filled in Arc.
 * Fill color is expected to be set using {@link setFill}.
 *
 * @param {Number} x X position of center of the Arc.
 * @param {Number} y Y position of center of the Arc.
 * @param {Number} r Radius of the Arc.
 * @param {Number} a0 first angle of the Arc.
 * @param {Number} a1 second angle of the Arc.
 * @example
 * setFill('steelblue');
 * fArc(40, 40, 20, 0.5, 0.8);
 *
 */
export function fArc(x, y, r, a0, a1, counterclockwise) {
  context.beginPath();
  context.arc(x, y, r, a0, a1, counterclockwise);
  context.fill();
}

/**
 * Draws a stroked Arc.
 * Stroke color is expected to be set using {@link setStroke}.
 *
 * @param {Number} x X position of center of the Arc.
 * @param {Number} y Y position of center of the Arc.
 * @param {Number} r Radius of the Arc.
 * @param {Number} a0 first angle of the Arc.
 * @param {Number} a1 second angle of the Arc.
 * @example
 * setStroke('orange', 5);
 * sArc(40, 40, 20, 0.5, 0.8);
 *
 */
export function sArc(x, y, r, a0, a1, counterclockwise) {
  context.beginPath();
  context.arc(x, y, r, a0, a1, counterclockwise);
  context.stroke();
}

/**
 * Draws a filled in Circle.
 * Fill color is expected to be set using {@link setFill}.
 *
 * @param {Number} x X position of center of the Circle.
 * @param {Number} y Y position of center of the Circle.
 * @param {Number} r Radius of the Circle.
 * @example
 * setFill('steelblue');
 * fCircle(40, 40, 20);
 *
 */
export function fCircle(x, y, r) {
  context.beginPath();
  context.arc(x, y, r, 0, TwoPi);
  context.fill();
}

/**
 * Draws a stroked Circle.
 * Stroke color is expected to be set using {@link setStroke}.
 *
 * @param {Number} x X position of center of the Circle.
 * @param {Number} y Y position of center of the Circle.
 * @param {Number} r Radius of the Circle.
 * @example
 * setStroke('orange', 5);
 * sCircle(40, 40, 20);
 *
 */
export function sCircle(x, y, r) {
  context.beginPath();
  context.arc(x, y, r, 0, TwoPi);
  context.stroke();
}

/**
 * Draws a filled and stroked Circle.
 * Fill color is expected to be set using {@link setFill}.
 * Stroke color is expected to be set using {@link setStroke}.
 *
 * @param {Number} x X position of center of the Circle.
 * @param {Number} y Y position of center of the Circle.
 * @param {Number} r Radius of the Circle.
 * @example
 * setStroke('steelblue');
 * sCircle(40, 40, 20);
 *
 */
export function fsCircle(x, y, r) {
  fCircle(x, y, r);
  context.stroke();
}

/**
 * Draws a filled in Ellipse.
 * Fill color is expected to be set using {@link setFill}.
 *
 * @param {Number} x X position of center of the Ellipse.
 * @param {Number} y Y position of center of the Ellipse.
 * @param {Number} rW Radial width of the Ellipse.
 * @param {Number} rH Radial height of the Ellipse.
 * @example
 * setFill('steelblue');
 * fEllipse(40, 40, 20, 30);
 */
export function fEllipse(x, y, rW, rH) {
  var k = 0.5522848, // 4 * ((√(2) - 1) / 3)
    ox = rW * k, // control point offset horizontal
    oy = rH * k, // control point offset vertical
    xe = x + rW, // x-end
    ye = y + rH; // y-end
  context.beginPath();
  context.moveTo(x - rW, y);
  context.bezierCurveTo(x - rW, y - oy, x - ox, y - rH, x, y - rH);
  context.bezierCurveTo(x + ox, y - rH, xe, y - oy, xe, y);
  context.bezierCurveTo(xe, y + oy, x + ox, ye, x, ye);
  context.bezierCurveTo(x - ox, ye, x - rW, y + oy, x - rW, y);
  context.moveTo(x - rW, y);
  context.closePath();
  context.fill();
}

/**
 * Draws a stroked Ellipse.
 * Stroke color is expected to be set using {@link setStroke}.
 *
 * @param {Number} x X position of center of the Ellipse.
 * @param {Number} y Y position of center of the Ellipse.
 * @param {Number} rW Radial width of the Ellipse.
 * @param {Number} rH Radial height of the Ellipse.
 * @example
 * setStroke('orange');
 * sEllipse(40, 40, 20, 30);
 */
export function sEllipse(x, y, rW, rH) {
  var k = 0.5522848,
    ox = rW * k,
    oy = rH * k,
    xe = x + rW,
    ye = y + rH;
  context.beginPath();
  context.moveTo(x - rW, y);
  context.bezierCurveTo(x - rW, y - oy, x - ox, y - rH, x, y - rH);
  context.bezierCurveTo(x + ox, y - rH, xe, y - oy, xe, y);
  context.bezierCurveTo(xe, y + oy, x + ox, ye, x, ye);
  context.bezierCurveTo(x - ox, ye, x - rW, y + oy, x - rW, y);
  context.moveTo(x - rW, y);
  context.closePath();
  context.stroke();
}

/**
 * Draws a filled and stroked Ellipse.
 * Fill color is expected to be set using {@link setFill}.
 * Stroke color is expected to be set using {@link setStroke}.
 *
 * @param {Number} x X position of center of the Ellipse.
 * @param {Number} y Y position of center of the Ellipse.
 * @param {Number} rW Radial width of the Ellipse.
 * @param {Number} rH Radial height of the Ellipse.
 * @example
 * setFill('steelblue');
 * setStroke('steelblue');
 * fsEllipse(40, 40, 20, 30);
 */
export function fsEllipse(x, y, rW, rH) {
  fEllipse(x, y, rW, rH);
  context.stroke();
}


/**
 * @ignore
 */
function _solidArc(x,y,a0,a1,r0,r1){
  context.beginPath();
  context.arc( x, y, r0, a0, a1 );
  context.lineTo( x + r1*Math.cos(a1), y + r1*Math.sin(a1) );
  context.arc( x, y, r1, a1, a0, true );
  context.lineTo( x + r0*Math.cos(a0), y + r0*Math.sin(a0) );
}

export function fSolidArc(x,y,a0,a1,r0,r1){
  _solidArc(x,y,a0,a1,r0,r1);
  context.fill();
}

export function sSolidArc(x,y,a0,a1,r0,r1){
  _solidArc(x,y,a0,a1,r0,r1);
  context.stroke();
}

export function fsSolidArc(x,y,a0,a1,r0,r1){
  fSolidArc(x,y,a0,a1,r0,r1);
  context.stroke();
}


/**
 * Draws a line from a start position to an end position
 *
 * @param {Number} x0 Starting x position.
 * @param {Number} y0 Starting y position.
 * @param {Number} x1 Ending x position.
 * @param {Number} y1 Ending y position.
 * @example
 * setStroke('black');
 * line(0, 0, 40, 40);
 */
export function line(x0, y0, x1, y1) {
  context.beginPath();
  context.moveTo(x0, y0);
  context.lineTo(x1, y1);
  context.stroke();
}

/**
 * Draws a bezier curve using {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/bezierCurveTo|bezierCurveTo}
 *
 * @param {Number} x0 Starting x position.
 * @param {Number} y0 Starting y position.
 * @param {Number} cx0 First curve control point x position.
 * @param {Number} cy0 First cure control point y position.
 * @param {Number} cx1 Second curve control point x position.
 * @param {Number} cy1 Second cure control point y position.
 * @param {Number} x1 Ending x position.
 * @param {Number} y1 Ending y position.
 * @example
 * setStroke('black');
 * bezier(10, 10, 10, 0, 40, 0, 40, 10);
 */
export function bezier(x0, y0, cx0, cy0, cx1, cy1, x1, y1) {
  context.beginPath();
  context.moveTo(x0, y0);
  context.bezierCurveTo(cx0, cy0, cx1, cy1, x1, y1);
  context.stroke();
}


/**
 * @ignore
 */
function _lines() {
  if(arguments == null) return;

  var args = arguments[0];
  context.beginPath();
  context.moveTo(args[0], args[1]);
  for(var i = 2; args[i + 1] != null; i += 2) {
    context.lineTo(args[i], args[i + 1]);
  }
}

/**
 * @ignore
 */
function _linesM() {
  if(arguments == null) return;

  var args = arguments[0];
  var p = new Polygon();
  context.beginPath();
  context.moveTo(args[0], args[1]);
  p[0] = new Point(args[0], args[1]);
  for(var i = 2; args[i + 1] != null; i += 2) {
    context.lineTo(args[i], args[i + 1]);
    p.push(new Point(args[i], args[i + 1]));
  }
  return p.containsPoint(mP);
}

/**
 * Draws a filled polygon using a series of
 * x/y positions.
 *
 * @param {...Number} positions x and y positions for the Polygon
 * @example
 * // This draws a filled triangle
 * // Inputs are pairs of x/y positions.
 * setFill('steelblue').
 * fLines(10, 10, 40, 10, 40, 40);
 *
 */
export function fLines() {
  _lines(arguments);
  context.fill();
}

/**
 * Draws a set of line segments using a series of
 * x/y positions as input.
 *
 * @param {...Number} positions x and y positions for the Lines
 * @example
 * // This draws the outline of a triangle.
 * // Inputs are pairs of x/y positions.
 * setStroke('orange');
 * sLines(10, 10, 40, 10, 40, 40, 10, 10);
 *
 */
export function sLines() {
  _lines(arguments);
  context.stroke();
}

/**
 * Draws a filled set of line segments using a series of
 * x/y positions as input.
 *
 * @param {...Number} positions x and y positions for the Lines
 * @example
 * // This draws a filled and outlined triangle.
 * // Inputs are pairs of x/y positions.
 * setFill('steelblue');
 * setStroke('orange');
 * fsLines(10, 10, 40, 10, 40, 40, 10, 10);
 *
 */
export function fsLines() {
  _lines(arguments);
  context.fill();
  context.stroke();
}

/**
 * Draws a mouse-enabled filled set of line segments using a series of
 * x/y positions as input. Returns true if moused over on current
 * cycle iteration.
 *
 * @param {...Number} positions x and y positions for the Lines
 * @returns {Boolean} if true, mouse is currently hovering over lines.
 * @example
 * // Turns Fill Red if moused over
 * setFill('steelblue');
 * setStroke('orange');
 * var on = fsLinesM(10, 10, 40, 10, 40, 40, 10, 10);
 * if(on) {
 *   setFill('red');
 *   fsLines(10, 10, 40, 10, 40, 40, 10, 10);
 * }
 *
 */
export function fsLinesM() {
  var mouseOn = _linesM(arguments);
  context.fill();
  context.stroke();
  return mouseOn;
}

/**
 * @ignore
 */
function _polygon(polygon) {
  context.beginPath();
  context.moveTo(polygon[0].x, polygon[0].y);
  for(var i = 1; polygon[i] != null; i++) {
    context.lineTo(polygon[i].x, polygon[i].y);
  }
}

export function fPolygon(polygon) {
  _polygon(polygon);
  context.fill();
}

export function sPolygon(polygon, closePath) {
  _polygon(polygon);
  if(closePath) context.closePath();
  context.stroke();
}

export function fsPolygon(polygon, closePath) {
  _polygon(polygon);
  if(closePath) context.closePath();
  context.fill();
  context.stroke();
}

export function fEqTriangle(x, y, angle, r) {
  _eqTriangle(x, y, angle, r);
  context.fill();
}

export function sEqTriangle(x, y, angle, r) {
  _eqTriangle(x, y, angle, r);
  context.stroke();
}

export function fsEqTriangle(x, y, angle, r) {
  _eqTriangle(x, y, angle, r);
  context.fill();
  context.stroke();
}

function _eqTriangle(x, y, angle, r) {
  context.beginPath();
  angle = angle || 0;
  context.moveTo(r * Math.cos(angle) + x, r * Math.sin(angle) + y);
  context.lineTo(r * Math.cos(angle + 2.0944) + x, r * Math.sin(angle + 2.0944) + y);
  context.lineTo(r * Math.cos(angle + 4.1888) + x, r * Math.sin(angle + 4.1888) + y);
  context.lineTo(r * Math.cos(angle) + x, r * Math.sin(angle) + y);
}


//drawing and checking cursor

/**
 * Draws a mouse-enabled filled in Rectangle.
 * Fill color is expected to be set using {@link setFill}.
 *
 * @param {Number} x X position of upper-left corner of Rectangle.
 * @param {Number} y Y position of upper-left corner of Rectangle.
 * @param {Number} width Width of Rectangle in pixels.
 * @param {Number} height Height of Rectangle in pixels.
 * @param {Number} margin Parameter around rectangle to count towards mouse over.
 * @return {Boolean} Returns true if the mouse is over the rectangle on the current
 * iteration of the cycle function.
 * @example
 * setFill('steelblue');
 * var on = fRectM(10, 10, 40, 40);
 * if(on) {
 *   setFill('red');
 *   fRect(10, 10, 40, 40);
 * }
 */
export function fRectM(x, y, width, height, margin) {
  margin = margin == null ? 0 : margin;
  context.fillRect(x, y, width, height);
  return mY > y - margin &amp;&amp; mY &lt; y + height + margin &amp;&amp; mX > x - margin &amp;&amp; mX &lt; x + width + margin;
}

/**
 * Draws a mouse-enabled stroked Rectangle.
 * Stroke color is expected to be set using {@link setStroke}.
 *
 * @param {Number} x X position of upper-left corner of Rectangle.
 * @param {Number} y Y position of upper-left corner of Rectangle.
 * @param {Number} width Width of Rectangle in pixels.
 * @param {Number} height Height of Rectangle in pixels.
 * @param {Number} margin Parameter around rectangle to count towards mouse over.
 * @return {Boolean} Returns true if the mouse is over the rectangle on the current
 * iteration of the cycle function.
 * @example
 * setStroke('orange');
 * var on = sRectM(10, 10, 40, 40);
 * if(on) {
 *   setStroke('black');
 *   sRect(10, 10, 40, 40);
 * }
 */
export function sRectM(x, y, width, height, margin) {
  margin = margin == null ? 0 : margin;
  context.strokeRect(x, y, width, height);
  return mY > y - margin &amp;&amp; mY &lt; y + height + margin &amp;&amp; mX > x - margin &amp;&amp; mX &lt; x + width + margin;
}

/**
 * Draws a mouse-enabled filled and stroked Rectangle.
 * Fill color is expected to be set using {@link setFill}.
 * Stroke color is expected to be set using {@link setStroke}.
 *
 * @param {Number} x X position of upper-left corner of Rectangle.
 * @param {Number} y Y position of upper-left corner of Rectangle.
 * @param {Number} width Width of Rectangle in pixels.
 * @param {Number} height Height of Rectangle in pixels.
 * @param {Number} margin Parameter around rectangle to count towards mouse over.
 * @return {Boolean} Returns true if the mouse is over the rectangle on the current
 * iteration of the cycle function.
 * @example
 * setFill('steelblue');
 * setStroke('orange');
 * var on = fsRectM(10, 10, 40, 40);
 * if(on) {
 *   setFill('red');
 *   setStroke('black');
 *   sRect(10, 10, 40, 40);
 * }
 */
export function fsRectM(x, y, width, height, margin) {
  margin = margin == null ? 0 : margin;
  context.fillRect(x, y, width, height);
  context.strokeRect(x, y, width, height);
  return mY > y - margin &amp;&amp; mY &lt; y + height + margin &amp;&amp; mX > x - margin &amp;&amp; mX &lt; x + width + margin;
}

/**
 * Draws a mouse-enabled filled in Circle.
 * Fill color is expected to be set using {@link setFill}.
 * Returns true if mouse is over circle on current iteration of cycle.
 *
 * @param {Number} x X position of center of the Circle.
 * @param {Number} y Y position of center of the Circle.
 * @param {Number} r Radius of the Circle.
 * @param {Number} margin Margin around Circle to consider part of mouse over.
 * @return {Boolean} Returns true if the mouse is over the circle on the current
 * iteration of the cycle function.
 * @example
 * setFill('steelblue');
 * var on = fCircleM(40, 40, 20);
 * if(on) {
 *  setFill('red');
 *  fCircle(40, 40, 20);
 * }
 *
 */
export function fCircleM(x, y, r, margin) { //check if you can avoid repeat
  margin = margin == null ? 0 : margin;
  context.beginPath();
  context.arc(x, y, r, 0, TwoPi);
  context.fill();
  return Math.pow(x - mX, 2) + Math.pow(y - mY, 2) &lt; Math.pow(r + margin, 2);
}

/**
 * Draws a mouse-enabled stroked Circle.
 * Stroke color is expected to be set using {@link setStroke}.
 * Returns true if mouse is over circle on current iteration of cycle.
 *
 * @param {Number} x X position of center of the Circle.
 * @param {Number} y Y position of center of the Circle.
 * @param {Number} r Radius of the Circle.
 * @param {Number} margin Margin around Circle to consider part of mouse over.
 * @return {Boolean} Returns true if the mouse is over the circle on the current
 * iteration of the cycle function.
 * @example
 * setStroke('orange');
 * var on = sCircleM(40, 40, 20);
 * if(on) {
 *  setStroke('black');
 *  sCircle(40, 40, 20);
 * }
 *
 */
export function sCircleM(x, y, r, margin) {
  margin = margin == null ? 0 : margin;
  context.beginPath();
  context.arc(x, y, r, 0, TwoPi);
  context.stroke();
  return Math.pow(x - mX, 2) + Math.pow(y - mY, 2) &lt; Math.pow(r + margin, 2);
}

/**
 * Draws a mouse-enabled filled and stroked Circle.
 * Fill color is expected to be set using {@link setFill}.
 * Stroke color is expected to be set using {@link setStroke}.
 * Returns true if mouse is over circle on current iteration of cycle.
 *
 * @param {Number} x X position of center of the Circle.
 * @param {Number} y Y position of center of the Circle.
 * @param {Number} r Radius of the Circle.
 * @param {Number} margin Margin around Circle to consider part of mouse over.
 * @return {Boolean} Returns true if the mouse is over the circle on the current
 * iteration of the cycle function.
 * @example
 * setFill('steelblue');
 * setStroke('orange');
 * var on = fsCircleM(40, 40, 20);
 * if(on) {
 *  setFill('red');
 *  setStroke('black');
 *  fsCircle(40, 40, 20);
 * }
 *
 */
export function fsCircleM(x, y, r, margin) {
  margin = margin == null ? 0 : margin;
  context.beginPath();
  context.arc(x, y, r, 0, TwoPi);
  context.stroke();
  context.fill();
  return Math.pow(x - mX, 2) + Math.pow(y - mY, 2) &lt; Math.pow(r + margin, 2);
}

/**
 * Draws a mouse-enabled line from a start position to an end position.
 *
 * @param {Number} x0 Starting x position.
 * @param {Number} y0 Starting y position.
 * @param {Number} x1 Ending x position.
 * @param {Number} y1 Ending y position.
 * @param {Number} d Distance away from line to count towards mouse interaction.
 * @return {Boolean} Returns true if the mouse is over the line on the current
 * iteration of the cycle function.
 * @example
 * setStroke('black');
 * var on = lineM(0, 0, 40, 40);
 * if(on) {
 *  setStroke('red');
 *  line(0, 0, 40, 40);
 * }
 */
export function lineM(x0, y0, x1, y1, d) {
  d = d || 4;
  context.beginPath();
  context.moveTo(x0, y0);
  context.lineTo(x1, y1);
  context.stroke();
  return _distToSegmentSquared(x0, y0, x1, y1) &lt; d * d;
}


/**
 * @ignore
 */
function _distToSegmentSquared(x0, y0, x1, y1) {
  var l2 = Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2);
  if(l2 === 0) return Math.pow(x0 - mX, 2) + Math.pow(y0 - mY, 2);
  var t = ((mX - x0) * (x1 - x0) + (mY - y0) * (y1 - y0)) / l2;
  if(t &lt;= 0) return Math.pow(x0 - mX, 2) + Math.pow(y0 - mY, 2);
  if(t >= 1) return Math.pow(x1 - mX, 2) + Math.pow(y1 - mY, 2);
  var px = x0 + t * (x1 - x0);
  var py = y0 + t * (y1 - y0);
  return Math.pow(px - mX, 2) + Math.pow(py - mY, 2);
}

//TODO:fEqTriangleM, fPolygonM


/**
 * Draws a mouse-enabled bezier curve using {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/bezierCurveTo|bezierCurveTo}.
 *
 *
 * @param {Number} x0 Starting x position.
 * @param {Number} y0 Starting y position.
 * @param {Number} cx0 First curve control point x position.
 * @param {Number} cy0 First cure control point y position.
 * @param {Number} cx1 Second curve control point x position.
 * @param {Number} cy1 Second cure control point y position.
 * @param {Number} x1 Ending x position.
 * @param {Number} y1 Ending y position.
 * @param {Number} d Distance away from line to count towards mouse interaction.
 * @return {Boolean} Returns true if the mouse is over the line on the current
 * iteration of the cycle function.
 * @example
 * setStroke('black');
 * var on = bezierM(10, 10, 10, 0, 40, 0, 40, 10);
 * if(on) {
 *  setStroke('red');
 *  bezierM(10, 10, 10, 0, 40, 0, 40, 10);
 * }
 */
export function bezierM(x0, y0, cx0, cy0, cx1, cy1, x1, y1, d) { //TODO: fix this mess!
  d = d == null ? 2 : d;
  context.beginPath();
  context.moveTo(x0, y0);
  context.bezierCurveTo(cx0, cy0, cx1, cy1, x1, y1);
  context.stroke();
  if(mX &lt; Math.min(x0, x1, cx0, cx1) - d || mX > Math.max(x0, x1, cx0, cx1) + d || mY &lt; Math.min(y0, y1, cy0, cy1) - d || mY > Math.max(y0, y1, cy0, cy1) + d) return false;
  return GeometryOperators.distanceToBezierCurve(x0, y0, cx0, cy0, cx1, cy1, x1, y1, mP, false) &lt; d;
}


//images

/**
 * draw an image on context, parameters options (s for source, d for destination):
 *	drawImage(image, dx, dy)
 *	drawImage(image, dx, dy, dw, dh)
 *	drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh)
 *	@param {Image} image
 */
export function drawImage(image) { //TODO: improve efficiency
  if(image == null) return;

  switch(arguments.length) {
    case 3:
      context.drawImage(image, arguments[1], arguments[2]);
      break;
    case 5:
      context.drawImage(image, arguments[1], arguments[2], arguments[3], arguments[4]);
      break;
    case 9:
      context.drawImage(image, arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6], arguments[7], arguments[8]);
      break;

  }
}

/**
 * fits an image into a rectangle without chagning its proportions (thus probably loosing top-bottom or left-right margins)
 * @param  {Image} image
 * @param  {Rectangle} rectangle frame of the image
 */
export function fitImage(image, rectangle) {
  if(image == null ||  rectangle == null) return;

  var propIm = image.width / image.height;
  var propRc = rectangle.width / rectangle.height;
  var compProp = propIm / propRc;

  if(propIm > propRc) {
    context.drawImage(image, 0.5 * (image.width - image.width / compProp), 0, image.width / compProp, image.height, rectangle.x, rectangle.y, rectangle.width, rectangle.height);
  } else {
    context.drawImage(image, 0, 0.5 * (image.height - image.height * compProp), image.width, image.height * compProp, rectangle.x, rectangle.y, rectangle.width, rectangle.height);
  }
}

// styles

/**
 * @todo write docs
 */
export function setFill(style) {
  if(typeof style == "number") {
    if(arguments.length > 3) {
      context.fillStyle = 'rgba(' + arguments[0] + ',' + arguments[1] + ',' + arguments[2] + ',' + arguments[3] + ')';
      return;
    }
    context.fillStyle = 'rgb(' + arguments[0] + ',' + arguments[1] + ',' + arguments[2] + ')';
    return;
  }
  context.fillStyle = style;
}

/**
 * setStroke - set stroke to draw with in canvas
 *
 * @param {(String|Number)} style If string, then hex value or web color.
 * If Number, then a set of RGB or RGBA integers
 * @param {Number} lineWidth Optional width of line to use. Only valid if style parameter is a string.
 * @example
 * setStroke('steelblue'); // sets stroke to blue.
 * setStroke(0,0,0,0.4); // sets stroke to black with partial opacity.
 * setStroke('black', 0.2); // provides lineWidth to stroke
 */
export function setStroke(style, lineWidth) {
  if(typeof style == "number") {
    if(arguments.length > 3) {
      context.strokeStyle = 'rgba(' + arguments[0] + ',' + arguments[1] + ',' + arguments[2] + ',' + arguments[3] + ')';
      return;
    }
    context.strokeStyle = 'rgb(' + arguments[0] + ',' + arguments[1] + ',' + arguments[2] + ')';
    return;
  }
  context.strokeStyle = style;
  //TODO: will lineWidth still work if RGB or RGBA is used?
  if(lineWidth) context.lineWidth = lineWidth;
}

/**
 * @todo write docs
 */
export function setLW(lineWidth) {
  context.lineWidth = lineWidth;
}


//clipping

/**
 * @todo write docs
 */
export function clipCircle(x, y, r) {
  context.save();
  context.beginPath();
  context.arc(x, y, r, 0, TwoPi, false);
  context.closePath();
  context.clip();
}

/**
 * @todo write docs
 */
export function clipRectangle(x, y, w, h) {
  context.save();
  context.beginPath();
  context.moveTo(x, y);
  context.lineTo(x + w, y);
  context.lineTo(x + w, y + h);
  context.lineTo(x, y + h);
  context.clip();
}

/**
 * @todo write docs
 */
export function save() {
  context.save();
}

/**
 * @todo write docs
 */
export function clip() {
  context.clip();
}

/**
 * @todo write docs
 */
export function restore() {
  context.restore();
}


// texts

/**
 * Draws filled in text.
 * Fill color is expected to be set using {@link setFill}.
 * Alternatively, setText can be used to set a number of
 * text rendering properties.
 *
 * @param {String} text Text to draw.
 * @param {Number} x X position to start the text.
 * @param {Number} y Y position to start the text.
 * @example
 * setText('black', 30, 'Ariel');
 * fText("hello", 10, 10);
 *
 */
export function fText(text, x, y) {
  context.fillText(text, x, y);
}

/**
 * Draws stroked text.
 * Stroke color is expected to be set using {@link setStroke}.
 * Additionally, setText can be used to set a number of
 * text rendering properties.
 *
 * @param {String} text Text to draw.
 * @param {Number} x X position to start the text.
 * @param {Number} y Y position to start the text.
 * @example
 * setText('black', 30, 'Ariel');
 * setStroke('orange');
 * sText("hello", 10, 10);
 *
 */
export function sText(text, x, y) {
  context.strokeText(text, x, y);
}

/**
 * Draws stroked and filled in text.
 * Stroke color is expected to be set using {@link setStroke}.
 * Fill color is expected to be set using {@link setFill}.
 * Alternatively, setText can be used to set a number of
 * text rendering properties.
 *
 * @param {String} text Text to draw.
 * @param {Number} x X position to start the text.
 * @param {Number} y Y position to start the text.
 * @example
 * setText('black', 30, 'Ariel');
 * setStroke('orange');
 * fsText("hello", 10, 10);
 *
 */
export function fsText(text, x, y) {
  context.strokeText(text, x, y);
  context.fillText(text, x, y);
}

/**
 * Draws filled in text, rotated by some angle.
 * Fill color is expected to be set using {@link setFill}.
 * Alternatively, setText can be used to set a number of
 * text rendering properties.
 *
 * @param {String} text Text to draw.
 * @param {Number} x X position to start the text.
 * @param {Number} y Y position to start the text.
 * @param {Number} angle The angle in radians to rotate the text
 * @example
 * setText('black', 30, 'Ariel');
 * fTextRotated("hello", 40, 40, (20 * Math.PI / 180));
 *
 */
export function fTextRotated(text, x, y, angle) {
  context.save();
  context.translate(x, y);
  context.rotate(angle);
  context.fillText(text, 0, 0);
  context.restore();
}

/**
 * Draws filled in text in an arc.
 * Fill color is expected to be set using {@link setFill}.
 * Alternatively, setText can be used to set a number of
 * text rendering properties.
 *
 * @param {String} text Text to draw.
 * @param {Number} x X position of control point, to start the text if not centered.
 * @param {Number} y Y position of control point, to start the text if not centered.
 * @param {Number} xCenter X position of center of arc.
 * @param {Number} yCenter Y position of center of arc.
 * @param {Boolean} centered if false (default) text starts on control point, if true the control point is the center of the text
 * @example
 * setText('black', 30, 'Ariel');
 * fTextArc("Wheels on the Bus Go Round and Round", 500, 300, 200, 200, true);
 *
 */
export function fTextArc(text, x, y, xCenter, yCenter, centered){
  if(text==null || text=="") return;

  var i;
  var xArc = 0;
  var r = Math.sqrt(Math.pow(x - xCenter, 2)+Math.pow(y - yCenter, 2));
  var a = Math.atan2(y - yCenter, x - xCenter);
  if(centered) a-=getTextW(text)*0.5/r;
  var xl, yl;

    var letters = text.split('');
    for(i=0; letters[i]!=null; i++){
      xl = xCenter + r*Math.cos(a);
      yl = yCenter + r*Math.sin(a);
      fTextRotated(letters[i], xl, yl, a+HalfPi);
      a+=getTextW(letters[i])/r;
    }
}

/**
 * Draws a mouse-enabled filled in text.
 * Fill color is expected to be set using {@link setFill}.
 * Alternatively, setText can be used to set a number of
 * text rendering properties.
 *
 * @param {String} text Text to draw.
 * @param {Number} x X position to start the text.
 * @param {Number} y Y position to start the text.
 * @param {Number} size Size of the text being drawn.
 * @return {Boolean} Returns true if the mouse is over the text on the current
 * iteration of the cycle function.
 * @example
 * setText('black', 30, 'Ariel');
 * var on = fTextM("hello", 10, 10, 30);
 * if(on) {
 *   setText('red', 30, 'Ariel');
 *   fText("hello", 10, 10);
 * }
 *
 */
export function fTextM(text, x, y, size) {
  size = size || 12;
  context.fillText(text, x, y);
  return mY > y &amp;&amp; mY &lt; y + size &amp;&amp; mX > x &amp;&amp; mX &lt; x + context.measureText(text).width;
}

/**
 * Draws a mouse-enabled filled and stroked text.
 * Fill color is expected to be set using {@link setFill}.
 * Stroke color is expected to be set using {@link setStroke}.
 * Alternatively, setText can be used to set a number of
 * text rendering properties.
 *
 * @param {String} text Text to draw.
 * @param {Number} x X position to start the text.
 * @param {Number} y Y position to start the text.
 * @param {Number} size Size of the text being drawn.
 * @return {Boolean} Returns true if the mouse is over the text on the current
 * iteration of the cycle function.
 * @example
 * setText('black', 30, 'Ariel');
 * setStroke('orange')
 * var on = fsTextM("hello", 10, 10, 30);
 * if(on) {
 *   setText('red', 30, 'Ariel');
 *   setStroke('black')
 *   fsText("hello", 10, 10);
 * }
 *
 */
export function fsTextM(text, x, y, size) {
  size = size || 12;
  context.strokeText(text, x, y);
  context.fillText(text, x, y);
  return mY > y &amp;&amp; mY &lt; y + size &amp;&amp; mX > x &amp;&amp; mX &lt; x + context.measureText(text).width;
}

/**
 * Draws a mouse-enabled filled text rotated by some angle.
 * Fill color is expected to be set using {@link setFill}.
 * Alternatively, setText can be used to set a number of
 * text rendering properties.
 *
 * @param {String} text Text to draw.
 * @param {Number} x X position to start the text.
 * @param {Number} y Y position to start the text.
 * @param {Number} angle The angle in radians to rotate the text
 * @param {Number} size Size of the text being drawn.
 * @return {Boolean} Returns true if the mouse is over the text on the current
 * iteration of the cycle function.
 * @example
 * setText('black', 30, 'Ariel');
 * var on = fTextRotatedM("hello", 10, 10, (20 * Math.PI / 180), 30);
 * if(on) {
 *   setText('red', 30, 'Ariel');
 *   setStroke('black')
 *   fsText("hello", 10, 10);
 * }
 *
 */
export function fTextRotatedM(text, x, y, angle, size) {
  size = size || 12;
  context.save();
  context.translate(x, y);
  context.rotate(angle);
  context.fillText(text, 0, 0);
  context.restore();

  var dX = mX - x;
  var dY = mY - y;
  var d = Math.sqrt(dX * dX + dY * dY);
  var a = Math.atan2(dY, dX) - angle;
  var mXT = x + d * Math.cos(a);
  var mYT = y + d * Math.sin(a);

  return mYT > y &amp;&amp; mYT &lt; y + size &amp;&amp; mXT > x &amp;&amp; mXT &lt; x + context.measureText(text).width;
}

export function fTextW(text, x, y) {
  context.fillText(text, x, y);
  return context.measureText(text).width;
}

/**
 * Sets several text canvas rendering properties
 *
 * @param {Object} color optional font color
 * @param {Object} fontSize optional font size
 * @param {Object} fontName optional font name (default: LOADED_FONT)
 * @param {Object} align optional horizontal align ('left', 'center', 'right')
 * @param {Object} baseline optional vertical alignment ('bottom', 'middle', 'top')
 * @param {Object} style optional font style ('bold', 'italic', 'underline')
 * @param {Object} ctx optional context
 */
export function setText(color, fontSize, fontName, align, baseline, style) {
  color = color || '#000000';
  fontSize = String(fontSize) || '14';
  fontName = fontName || LOADED_FONT;
  align = align == null ? 'left' : align;
  baseline = baseline == null ? 'top' : baseline;
  style = style == null ? '' : style;

  if(style != '') {
    style += ' ';
  }

  context.fillStyle = color;
  context.font = style + fontSize + 'px ' + fontName;
  context.textAlign = align;
  context.textBaseline = baseline;
}

/**
 * @todo write docs
 */
export function getTextW(text) {
  return context.measureText(text).width;
}



// pixel data

/**
 * @todo write docs
 */
export function getPixelData(x, y) {
  return context.getImageData(x, y, 1, 1).data;
}

/**
 * @todo write docs
 */
export function getPixelColor(x, y) {
  var rgba = context.getImageData(x, y, 1, 1).data;
  return 'rgba(' + rgba[0] + ',' + rgba[1] + ',' + rgba[2] + ',' + rgba[3] + ')';
}

/**
 * @todo write docs
 */
export function getPixelColorRGBA(x, y) { //repeated
  return context.getImageData(x, y, 1, 1).data;
}

/**
 * @todo write docs
 */
export function captureCanvas() {
  var im = new Image();
  im.src = canvas.toDataURL();
  return im;
}


/*
TODO: refactor this to not reassign Global.context
export function drawAndcapture(drawFunction, w, h, target) {
  var defaultContext = context;

  context = hiddenContext;

  context.canvas.setAttribute('width', w);
  context.canvas.setAttribute('height', h);

  context.clearRect(0, 0, w, h);

  target == null ? drawFunction.call() : drawFunction.call(target);

  var im = new Image();
  im.src = context.canvas.toDataURL();

  context = defaultContext;

  return im;
};
*/



//cursor

/**
 * Change mouse cursor to given style. See {@link https://developer.mozilla.org/en-US/docs/Web/CSS/cursor|MDN Cursor Page} for all style options.
 * @param {String} name The name of the cursor style.
 */
export function setCursor(name) {
  name = name == null ? 'default' : name;
  canvas.style.cursor = name;
}



//time

/**
 * @todo write docs
 */
export function getMilliseconds() {
  return new Date().getTime();
}


/**
 * @todo write docs
 */
export function getWindowFrame(){
  return new Rectangle(0,0,cW,cH);
}



//advanced graphics (rely on Axis2D projection object)

/**
 * @ignore
 */
export function _linesInFrame(axis2D, numberListX, numberListY){
  var l = Math.min(numberListX.length, numberListY.length);
  var i;

  context.beginPath();
  context.moveTo(axis2D.projectX(numberListX[0]), axis2D.projectY(numberListY[0]));

  for(i=1; i&lt;l; i++){
    context.lineTo(axis2D.projectX(numberListX[i]), axis2D.projectY(numberListY[i]));
  }
}


/**
 * @todo write docs
 */
export function sLinesInFrame(axis2D, numberListX, numberListY){
  _linesInFrame(axis2D, numberListX, numberListY);
  context.stroke();
}

/**
 * @todo write docs
 */
export function fLinesInFrame(axis2D, numberListX, numberListY){
  _linesInFrame(axis2D, numberListX, numberListY);
  context.fill();
}

/**
 * @todo write docs
 */
export function fsLinesInFrame(axis2D, numberListX, numberListY){
  _linesInFrame(axis2D, numberListX, numberListY);
  context.fill();
  context.stroke();
}


/**
 * @todo write docs
 */
export function drawGridX(axis2D, dX, yLabel, stepsLabel){
  var x0, y0;
  var n;
  var i;
  var x, y, top, bottom;

  x0 = Math.floor(axis2D.departureFrame.x/dX)*dX;
  n = Math.min( Math.ceil(axis2D.departureFrame.width/dX), 1000 );
  top = Math.min(axis2D.arrivalFrame.y, axis2D.arrivalFrame.y+axis2D.arrivalFrame.height);
  bottom = Math.max(axis2D.arrivalFrame.y, axis2D.arrivalFrame.y+axis2D.arrivalFrame.height);
  stepsLabel = stepsLabel==null?1:stepsLabel;
  for(i=0; i&lt;n; i++){
    x = Math.floor(axis2D.projectX(x0 + i*dX))+0.5;
    line(x, top, x, bottom);
    if(yLabel!=null &amp;&amp; i%stepsLabel==0) fText(String(x0 + i*dX), x, bottom+yLabel);
  }
}

/**
 * @todo write docs
 */
export function drawGridY(axis2D, dY, xLabel, stepsLabel){
  var x0, y0;
  var n;
  var i;
  var x, y, left, right;

  y0 = Math.floor(axis2D.departureFrame.y/dY)*dY;
  n = Math.min( Math.ceil(axis2D.departureFrame.height/dY), 1000 );
  left = Math.min(axis2D.arrivalFrame.x, axis2D.arrivalFrame.x+axis2D.arrivalFrame.width);
  right = Math.max(axis2D.arrivalFrame.x, axis2D.arrivalFrame.x+axis2D.arrivalFrame.width);
  stepsLabel = stepsLabel==null?1:stepsLabel;
  for(i=0; i&lt;n; i++){
    y = Math.floor(axis2D.projectY(y0 + i*dY))+0.5;
    line(left, y, right, y);
    if(xLabel!=null &amp;&amp; i%stepsLabel==0) fText(String(y0 + i*dY), left+xLabel, y);
  }
}
</code></pre>
        </article>
    </section>




      </div>
    </div>
    <div class='quiet small center pad1y'>
    </div>
  </div>
  <script src="http://code.jquery.com/jquery-1.11.3.min.js"></script>
  <script src="scripts/filter.js"></script>
  <script src="scripts/prettify/prettify.js"></script>
</body>
</html>
